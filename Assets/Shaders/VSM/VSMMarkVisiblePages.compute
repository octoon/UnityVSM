#pragma kernel MarkVisiblePages

#include "../Include/VSMCommon.hlsl"

// Input depth buffer from camera
Texture2D<float> _CameraDepthTexture;
SamplerState sampler_CameraDepthTexture;

// Virtual Page Table
RWTexture2DArray<uint> _VirtualPageTable;

// Allocation requests buffer
struct AllocationRequest
{
    int3 pageCoords;
    uint padding;
};
AppendStructuredBuffer<AllocationRequest> _AllocationRequests;

// Camera and cascade data
float4x4 _CameraInverseViewProjection;
float4x4 _CameraViewProjection;
float3 _CameraPosition;
float _FirstCascadeSize;

StructuredBuffer<float4x4> _CascadeLightMatrices;
StructuredBuffer<int2> _CascadeOffsets;

uint _ScreenWidth;
uint _ScreenHeight;
int _FilterMargin;  // Margin in pages for PCF filtering support
int _UsePixelPerfectHeuristic;  // 0 = distance-based, 1 = pixel-perfect
float _CascadeBias;  // Bias for cascade selection

float3 ReconstructWorldPosition(float2 uv, float depth)
{
    // FIXED: Improved platform compatibility for depth reconstruction

    // Handle depth range differences across platforms
    #if defined(UNITY_REVERSED_Z)
        // DX12/Vulkan/Metal: depth is [1 (near), 0 (far)]
        // Convert to clip space Z range [-1, 1] for OpenGL or [0, 1] for DX
        #if SHADER_API_OPENGL || SHADER_API_GLES || SHADER_API_GLES3
            depth = (1.0 - depth) * 2.0 - 1.0;  // [1,0] -> [0,1] -> [-1,1]
        #else
            // DX/Vulkan/Metal use [0,1] clip space
            depth = 1.0 - depth;  // [1,0] -> [0,1]
        #endif
    #else
        // OpenGL: depth is [0 (near), 1 (far)]
        depth = depth * 2.0 - 1.0;  // [0,1] -> [-1,1]
    #endif

    // Build clip space position
    float4 clipPos;
    clipPos.x = uv.x * 2.0 - 1.0;
    clipPos.y = (1.0 - uv.y) * 2.0 - 1.0;  // FIXED: Direct UV flip for Unity
    clipPos.z = depth;
    clipPos.w = 1.0;

    // Transform to world space
    float4 worldPos = mul(_CameraInverseViewProjection, clipPos);
    return worldPos.xyz / worldPos.w;
}

[numthreads(8, 8, 1)]
void MarkVisiblePages(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= _ScreenWidth || id.y >= _ScreenHeight)
        return;

    float2 uv = (id.xy + 0.5) / float2(_ScreenWidth, _ScreenHeight);
    float depth = _CameraDepthTexture.SampleLevel(sampler_CameraDepthTexture, uv, 0);

    // Skip skybox/far plane
    // FIXED: Handle reversed Z properly
    #if defined(UNITY_REVERSED_Z)
        // DX12/Vulkan/Metal: near=1, far=0
        // Skip if depth is 0 (far plane)
        if (depth <= 0.0)
            return;
    #else
        // OpenGL: near=0, far=1
        // Skip if depth is 1 (far plane)
        if (depth >= 1.0)
            return;
    #endif

    // Reconstruct world position
    float3 worldPos = ReconstructWorldPosition(uv, depth);

    // Calculate cascade level using selected heuristic
    int cascadeLevel;
    if (_UsePixelPerfectHeuristic > 0)
    {
        // First heuristic: Pixel-perfect (one-to-one mapping)
        float screenTexelWorldSize = GetScreenTexelWorldSize(worldPos, _CameraViewProjection, float2(_ScreenWidth, _ScreenHeight));
        float cascade0TexelWorldSize = _FirstCascadeSize / VSM_VIRTUAL_TEXTURE_RESOLUTION;
        cascadeLevel = CalculateCascadeLevelPixelPerfect(screenTexelWorldSize, cascade0TexelWorldSize, _CascadeBias);
    }
    else
    {
        // Second heuristic: Distance-based (rotationally invariant)
        cascadeLevel = CalculateCascadeLevel(worldPos, _CameraPosition, _FirstCascadeSize);
    }

    // Transform to light space
    float4x4 lightMatrix = _CascadeLightMatrices[cascadeLevel];
    float2 lightSpaceUV = WorldToLightSpaceUV(worldPos, lightMatrix);

    // Check if in valid range
    if (any(lightSpaceUV < 0.0) || any(lightSpaceUV > 1.0))
        return;

    // Calculate virtual page coordinates
    int2 basePage = int2(floor(lightSpaceUV * VSM_PAGE_TABLE_RESOLUTION));
    int2 cascadeOffset = _CascadeOffsets[cascadeLevel];

    // Mark the page and surrounding pages for filtering support
    // Paper section 12.2.3: "we mark all pages lying in a region around it"
    for (int dy = -_FilterMargin; dy <= _FilterMargin; dy++)
    {
        for (int dx = -_FilterMargin; dx <= _FilterMargin; dx++)
        {
            int3 pageCoords = int3(basePage + int2(dx, dy), cascadeLevel);

            // Convert to wrapped coordinates
            int3 wrappedCoords = VirtualPageCoordsToWrappedCoords(pageCoords, cascadeOffset);

            if (wrappedCoords.x < 0)
                continue;

            // Read page entry
            uint pageEntry = _VirtualPageTable[wrappedCoords];

            // Paper: Three cases based on page state
            // CRITICAL: Use VISIBLE bit (not ALLOCATED) to prevent duplicate allocation requests!
            // If page is visible (even if not allocated), it means another thread already requested it
            if (!GetIsAllocated(pageEntry))
            {
                if (!GetIsVisible(pageEntry))
                {
                    // Case 1: Page not allocated AND not visible - request allocation
                    // Set VISIBLE and DIRTY bits atomically to mark "allocation requested"
                    // Only AllocatePages will set ALLOCATED bit after assigning physical page
                    uint previousValue;
                    InterlockedCompareExchange(_VirtualPageTable[wrappedCoords],
                        pageEntry,  // Compare with read value (should be 0 or just dirty)
                        pageEntry | VSM_VISIBLE_BIT | VSM_DIRTY_BIT,  // Set VISIBLE|DIRTY
                        previousValue);  // Get previous value

                    // Only the thread that successfully set VISIBLE bit appends the request
                    // This ensures exactly ONE allocation request per page
                    if (previousValue == pageEntry)
                    {
                        AllocationRequest request;
                        request.pageCoords = pageCoords;
                        request.padding = 0;
                        _AllocationRequests.Append(request);
                    }
                }
                // Case 1b: Page not allocated BUT visible - already requested by another thread, skip
            }
            else if (!GetIsVisible(pageEntry))
            {
                // Case 2: Page allocated but not visible - mark as visible AND dirty
                // CRITICAL: Only append one clear request using atomic OR's previous value
                uint prevValue;
                InterlockedOr(_VirtualPageTable[wrappedCoords], VSM_VISIBLE_BIT | VSM_DIRTY_BIT, prevValue);

                if ((prevValue & VSM_VISIBLE_BIT) == 0)
                {
                    AllocationRequest request;
                    request.pageCoords = pageCoords;
                    request.padding = 0;
                    _AllocationRequests.Append(request);
                }
            }
            // Case 3: Page allocated and visible - do nothing
        }
    }
}
