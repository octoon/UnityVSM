#pragma kernel CompareUVs

#include "../Include/VSMCommon.hlsl"

// Camera and cascade data (same as MarkVisiblePages)
float4x4 _CameraInverseViewProjection;
float3 _CameraPosition;
float _FirstCascadeSize;

StructuredBuffer<float4x4> _CascadeLightMatrices;
StructuredBuffer<int2> _CascadeOffsets;

// Test world position
float3 _TestWorldPos;

// Output buffer: [0]=markVisible UV.x, [1]=markVisible UV.y, [2]=sample UV.x, [3]=sample UV.y
RWStructuredBuffer<float> _ComparisonOutput;

float3 ReconstructWorldPosition(float2 uv, float depth)
{
    float4 clipPos = float4(uv * 2.0 - 1.0, depth, 1.0);
    clipPos.y = -clipPos.y;  // Flip Y for Unity
    float4 worldPos = mul(_CameraInverseViewProjection, clipPos);
    return worldPos.xyz / worldPos.w;
}

[numthreads(1, 1, 1)]
void CompareUVs(uint3 id : SV_DispatchThreadID)
{
    float3 worldPos = _TestWorldPos;

    // Method 1: MarkVisiblePages method
    int cascadeLevel1 = CalculateCascadeLevel(worldPos, _CameraPosition, _FirstCascadeSize);
    float4x4 lightMatrix1 = _CascadeLightMatrices[cascadeLevel1];
    float2 lightSpaceUV1 = WorldToLightSpaceUV(worldPos, lightMatrix1);

    // Method 2: VSMForwardLit method
    int cascade2 = CalculateCascadeLevel(worldPos, _CameraPosition, _FirstCascadeSize);
    float4x4 lightMat2 = _CascadeLightMatrices[cascade2];
    float4 lightSpace2 = mul(lightMat2, float4(worldPos, 1.0));
    float3 ndc2 = lightSpace2.xyz / lightSpace2.w;
    float2 uv2 = ndc2.xy * 0.5 + 0.5;

    _ComparisonOutput[0] = lightSpaceUV1.x;
    _ComparisonOutput[1] = lightSpaceUV1.y;
    _ComparisonOutput[2] = uv2.x;
    _ComparisonOutput[3] = uv2.y;
    _ComparisonOutput[4] = (float)cascadeLevel1;
    _ComparisonOutput[5] = (float)cascade2;
}
