#pragma kernel ClearDirtyPages
#pragma kernel ClearDirtyFlags

#include "../Include/VSMCommon.hlsl"

// Physical memory buffer - use StructuredBuffer for atomic operations compatibility
RWStructuredBuffer<uint> _PhysicalMemoryBuffer;
uint _PhysicalMemoryWidth;  // For 2D to 1D index conversion

// Allocation requests (these pages are dirty and need clearing)
struct AllocationRequest
{
    int3 pageCoords;
    uint padding;
};
StructuredBuffer<AllocationRequest> _AllocationRequests;

// Virtual Page Table to look up physical coordinates
Texture2DArray<uint> _VirtualPageTable;
StructuredBuffer<int2> _CascadeOffsets;

uint _AllocationRequestCount;

[numthreads(8, 8, 1)]
void ClearDirtyPages(uint3 id : SV_DispatchThreadID)
{
    uint requestIndex = id.z;
    if (requestIndex >= _AllocationRequestCount)
        return;

    AllocationRequest request = _AllocationRequests[requestIndex];
    int3 pageCoords = request.pageCoords;

    // Get wrapped coordinates
    int2 cascadeOffset = _CascadeOffsets[pageCoords.z];
    int3 wrappedCoords = VirtualPageCoordsToWrappedCoords(pageCoords, cascadeOffset);

    if (wrappedCoords.x < 0)
        return;

    // Look up physical page coordinates from VPT
    uint pageEntry = _VirtualPageTable[wrappedCoords];
    if (!GetIsAllocated(pageEntry))
        return;

    int2 physicalPageCoords = UnpackPhysicalPageCoords(pageEntry);

    // Calculate texel coordinates within the page
    if (id.x >= VSM_PAGE_SIZE || id.y >= VSM_PAGE_SIZE)
        return;

    int2 texelCoordsInPage = id.xy;
    int2 physicalTexelCoords = physicalPageCoords * VSM_PAGE_SIZE + texelCoordsInPage;

    // Convert 2D to 1D index for StructuredBuffer
    uint bufferIndex = physicalTexelCoords.y * _PhysicalMemoryWidth + physicalTexelCoords.x;

    // Clear to far plane (1.0 as uint bits)
    _PhysicalMemoryBuffer[bufferIndex] = asuint(1.0);

    // Note: do not clear DIRTY bit here; it is used by HPB and draw this frame.
}

// Finalize pass: clear DIRTY bit for each requested page once after drawing completes
[numthreads(64, 1, 1)]
void ClearDirtyFlags(uint3 id : SV_DispatchThreadID)
{
    uint requestIndex = id.x;
    if (requestIndex >= _AllocationRequestCount)
        return;

    AllocationRequest request = _AllocationRequests[requestIndex];
    int3 pageCoords = request.pageCoords;

    int2 cascadeOffset = _CascadeOffsets[pageCoords.z];
    int3 wrappedCoords = VirtualPageCoordsToWrappedCoords(pageCoords, cascadeOffset);
    if (wrappedCoords.x < 0)
        return;

    // Clear DIRTY bit atomically
    InterlockedAnd(_VirtualPageTable[wrappedCoords], ~VSM_DIRTY_BIT);
}
