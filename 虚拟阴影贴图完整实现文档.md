# è™šæ‹Ÿé˜´å½±è´´å›¾ï¼ˆVirtual Shadow Mapsï¼‰å®Œæ•´å®ç°æ–‡æ¡£

## ğŸ“‹ ç›®å½•

1. [æŠ€æœ¯æ¦‚è¿°](#æŠ€æœ¯æ¦‚è¿°)
2. [æ ¸å¿ƒæ¦‚å¿µ](#æ ¸å¿ƒæ¦‚å¿µ)
3. [ç³»ç»Ÿæ¶æ„](#ç³»ç»Ÿæ¶æ„)
4. [ä¸‰å¤§æ‰§è¡Œé˜¶æ®µ](#ä¸‰å¤§æ‰§è¡Œé˜¶æ®µ)
5. [å…³é”®ç®—æ³•è¯¦è§£](#å…³é”®ç®—æ³•è¯¦è§£)
6. [æ•°æ®ç»“æ„è®¾è®¡](#æ•°æ®ç»“æ„è®¾è®¡)
7. [Shaderå®ç°ç»†èŠ‚](#shaderå®ç°ç»†èŠ‚)
8. [ä½¿ç”¨æŒ‡å—](#ä½¿ç”¨æŒ‡å—)
9. [æ€§èƒ½ä¼˜åŒ–](#æ€§èƒ½ä¼˜åŒ–)
10. [é—®é¢˜æ’æŸ¥](#é—®é¢˜æ’æŸ¥)

---

## æŠ€æœ¯æ¦‚è¿°

### ä»€ä¹ˆæ˜¯è™šæ‹Ÿé˜´å½±è´´å›¾ï¼ˆVSMï¼‰ï¼Ÿ

è™šæ‹Ÿé˜´å½±è´´å›¾æ˜¯ä¸€ç§åŸºäº**è™šæ‹Ÿçº¹ç†ï¼ˆVirtual Texturingï¼‰**æŠ€æœ¯çš„é«˜çº§é˜´å½±æ˜ å°„æ–¹æ³•ï¼Œé¦–æ¬¡åº”ç”¨äºUnreal Engine 5ã€‚å®ƒé€šè¿‡å°†è™šæ‹Ÿåœ°å€ç©ºé—´ä¸ç‰©ç†å†…å­˜åˆ†ç¦»ï¼Œå®ç°äº†ï¼š

- âœ… **è¶…é«˜åˆ†è¾¨ç‡é˜´å½±** - æ”¯æŒ4096Ã—4096Ã—16çº§è”çš„è™šæ‹Ÿåˆ†è¾¨ç‡
- âœ… **æä½å†…å­˜å ç”¨** - åªåˆ†é…å¯è§é¡µé¢ï¼Œå…¸å‹åœºæ™¯èŠ‚çœ90%+å†…å­˜
- âœ… **ç»Ÿä¸€é˜´å½±ç®¡çº¿** - æ›¿ä»£å¤šç§é˜´å½±æŠ€æœ¯çš„ç»„åˆæ–¹æ¡ˆ
- âœ… **è‡ªåŠ¨ç»†èŠ‚åˆ†é…** - æ ¹æ®è·ç¦»å’Œè§†è§’è‡ªåŠ¨è°ƒæ•´é˜´å½±ç²¾åº¦

### æ ¸å¿ƒä¼˜åŠ¿

| ä¼ ç»Ÿé˜´å½±è´´å›¾ | è™šæ‹Ÿé˜´å½±è´´å›¾ |
|------------|------------|
| å›ºå®šåˆ†è¾¨ç‡ï¼Œæµªè´¹å†…å­˜ | ç¨€ç–åˆ†é…ï¼ŒæŒ‰éœ€åŠ è½½ |
| éœ€è¦å¤šç§æŠ€æœ¯ç»„åˆï¼ˆCSMã€æ¥è§¦é˜´å½±ç­‰ï¼‰ | å•ä¸€ç»Ÿä¸€æ–¹æ¡ˆ |
| é€è§†å¤±çœŸä¸¥é‡ | è‡ªé€‚åº”ç»†èŠ‚å±‚çº§ |
| éš¾ä»¥æ”¯æŒé«˜å¤šè¾¹å½¢åœºæ™¯ | ä¸Naniteç­‰æŠ€æœ¯å®Œç¾é…åˆ |

---

## æ ¸å¿ƒæ¦‚å¿µ

### 1. è™šæ‹Ÿå†…å­˜ç³»ç»Ÿ

```
è™šæ‹Ÿåœ°å€ç©ºé—´ï¼ˆ4096Ã—4096Ã—16ï¼‰
        â†“ é¡µè¡¨æ˜ å°„
ç‰©ç†å†…å­˜ï¼ˆ8192Ã—4096ï¼Œä»…2048é¡µï¼‰
```

#### å…³é”®ç»„ä»¶ï¼š

**è™šæ‹Ÿé¡µè¡¨ï¼ˆVPTï¼‰**
- ç±»å‹ï¼š3Dçº¹ç†æ•°ç»„ï¼Œæ¯ä¸ªçº§è”32Ã—32é¡µ
- å­˜å‚¨ï¼šæ¯ä¸ªé¡µé¢çš„çŠ¶æ€æ ‡å¿—å’Œç‰©ç†åæ ‡
- åŠŸèƒ½ï¼šè™šæ‹Ÿé¡µâ†’ç‰©ç†é¡µçš„æ˜ å°„æŸ¥æ‰¾

**ç‰©ç†é¡µè¡¨ï¼ˆPPTï¼‰**
- ç±»å‹ï¼šComputeBuffer
- å­˜å‚¨ï¼šç‰©ç†é¡µâ†’è™šæ‹Ÿé¡µçš„åå‘æ˜ å°„
- åŠŸèƒ½ï¼šé¡µé¢é‡ç”¨æ—¶å¿«é€Ÿé‡Šæ”¾æ—§æ˜ å°„

**ç‰©ç†å†…å­˜æ± **
- ç±»å‹ï¼šRenderTextureï¼ˆR32_Floatï¼‰
- åˆ†è¾¨ç‡ï¼š8192Ã—4096åƒç´ 
- é¡µé¢å¸ƒå±€ï¼š64åˆ—Ã—32è¡Œ = 2048ä¸ªç‰©ç†é¡µ
- æ¯é¡µå¤§å°ï¼š128Ã—128åƒç´ 

### 2. é¡µé¢ç”Ÿå‘½å‘¨æœŸ

```
[æœªåˆ†é…] â†’ [åˆ†é…+å¯è§+è„] â†’ [åˆ†é…+å¯è§+å¹²å‡€] â†’ [åˆ†é…+ä¸å¯è§] â†’ [æœªåˆ†é…]
    â†‘            â†“                  â†“                  â†“              â†‘
    |         é¦–æ¬¡åˆ†é…           æ¸²æŸ“å®Œæˆ          ç¦»å¼€è§†é‡        è¢«å¤ç”¨
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

#### é¡µé¢çŠ¶æ€æ ‡å¿—ï¼š

```hlsl
#define VSM_ALLOCATED_BIT 0x1u  // å·²åˆ†é…ç‰©ç†å†…å­˜
#define VSM_VISIBLE_BIT 0x2u    // å½“å‰å¸§å¯è§
#define VSM_DIRTY_BIT 0x4u      // éœ€è¦é‡æ–°æ¸²æŸ“
```

### 3. çº§è”ç³»ç»Ÿ

16ä¸ªåŒå¿ƒçº§è”ï¼Œæ¯ä¸ªçº§è”å°ºå¯¸æ˜¯ä¸Šä¸€çº§çš„2å€ï¼š

```
çº§è”0: 2Ã—2ç±³ï¼ˆæœ€é«˜ç²¾åº¦ï¼Œé è¿‘ç›¸æœºï¼‰
çº§è”1: 4Ã—4ç±³
çº§è”2: 8Ã—8ç±³
...
çº§è”15: 65536Ã—65536ç±³ï¼ˆè¦†ç›–65kmï¼‰
```

æ¯ä¸ªçº§è”éƒ½æœ‰ç‹¬ç«‹çš„è™šæ‹Ÿé¡µè¡¨ï¼ˆ32Ã—32ï¼‰ï¼Œå…±äº«åŒä¸€ç‰©ç†å†…å­˜æ± ã€‚

### 4. é¡µé¢ç¼“å­˜ä¸æ»‘åŠ¨çª—å£

ä¸ºäº†æ”¯æŒç¼“å­˜ï¼Œçº§è”è§†é”¥éœ€è¦å¯¹é½åˆ°é¡µé¢ç½‘æ ¼ï¼š

```cpp
// é¡µé¢ç½‘æ ¼å¯¹é½
float pageWorldSize = cascadeSize / PAGE_TABLE_RESOLUTION;
Vector3 snappedPos = floor(cameraPos / pageWorldSize) * pageWorldSize;
```

**æ»‘åŠ¨çª—å£ï¼ˆWraparound Addressingï¼‰**ï¼š
å½“ç›¸æœºç§»åŠ¨æ—¶ï¼Œè™šæ‹Ÿé¡µè¡¨ä½¿ç”¨ç¯å½¢ç¼“å†²åŒºï¼Œæ–°è¿›å…¥çš„é¡µé¢å¤ç”¨é€€å‡ºé¡µé¢çš„ä½ç½®ï¼š

```hlsl
int2 wrappedCoords = (pageCoords + cascadeOffset) % PAGE_TABLE_RESOLUTION;
```

---

## ç³»ç»Ÿæ¶æ„

### æ•´ä½“æµç¨‹å›¾

```
æ¯å¸§æ‰§è¡Œï¼š
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚         OnPreRender()                   â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚   ExecuteVSMPipeline()          â”‚   â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚   â”‚
â”‚  â”‚  â”‚ 1. Bookkeeping é˜¶æ®µ        â”‚  â”‚   â”‚
â”‚  â”‚  â”‚   - é‡Šæ”¾å¤±æ•ˆé¡µé¢           â”‚  â”‚   â”‚
â”‚  â”‚  â”‚   - æ ‡è®°å¯è§é¡µé¢           â”‚  â”‚   â”‚
â”‚  â”‚  â”‚   - å¡«å……åˆ†é…å™¨ç¼“å†²åŒº       â”‚  â”‚   â”‚
â”‚  â”‚  â”‚   - åˆ†é…ç‰©ç†é¡µé¢           â”‚  â”‚   â”‚
â”‚  â”‚  â”‚   - æ¸…é™¤è„é¡µé¢             â”‚  â”‚   â”‚
â”‚  â”‚  â”‚   - æ„å»ºHPB               â”‚  â”‚   â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚   â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚   â”‚
â”‚  â”‚  â”‚ 2. Drawing é˜¶æ®µ â­         â”‚  â”‚   â”‚
â”‚  â”‚  â”‚   - éå†16ä¸ªçº§è”           â”‚  â”‚   â”‚
â”‚  â”‚  â”‚   - è§†é”¥å‰”é™¤              â”‚  â”‚   â”‚
â”‚  â”‚  â”‚   - HPBå‰”é™¤ï¼ˆå¯é€‰ï¼‰        â”‚  â”‚   â”‚
â”‚  â”‚  â”‚   - æ¸²æŸ“å‡ ä½•åˆ°ç‰©ç†å†…å­˜     â”‚  â”‚   â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚   â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚   â”‚
â”‚  â”‚  â”‚ 3. ç»‘å®šæ•°æ®ä¾›é‡‡æ ·          â”‚  â”‚   â”‚
â”‚  â”‚  â”‚   - è®¾ç½®å…¨å±€Shaderå‚æ•°     â”‚  â”‚   â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                 â†“
         æ¸²æŸ“ä¸»åœºæ™¯æ—¶é‡‡æ ·VSM
```

### æ ¸å¿ƒç±»è®¾è®¡

```
VirtualShadowMapManager (ä¸»ç®¡ç†å™¨)
â”œâ”€â”€ VSMPageTable (è™šæ‹Ÿé¡µè¡¨)
â”‚   â”œâ”€â”€ virtualPageTable: RenderTexture
â”‚   â”œâ”€â”€ allocationRequests: ComputeBuffer
â”‚   â”œâ”€â”€ freePhysicalPages: ComputeBuffer
â”‚   â””â”€â”€ usedPhysicalPages: ComputeBuffer
â”‚
â”œâ”€â”€ VSMPhysicalPageTable (ç‰©ç†é¡µè¡¨)
â”‚   â””â”€â”€ physicalPageTable: ComputeBuffer
â”‚
â”œâ”€â”€ VSMPhysicalMemory (ç‰©ç†å†…å­˜)
â”‚   â””â”€â”€ texture: RenderTexture (8192Ã—4096)
â”‚
â””â”€â”€ VSMHierarchicalPageBuffer (å±‚çº§é¡µé¢ç¼“å†²)
    â””â”€â”€ hpbMipChain: RenderTexture[] (mipé“¾)
```

---

## ä¸‰å¤§æ‰§è¡Œé˜¶æ®µ

### é˜¶æ®µä¸€ï¼šBookkeepingï¼ˆå‡†å¤‡é˜¶æ®µï¼‰

**ä½ç½®**ï¼š`VirtualShadowMapManager.cs:178-318`

è¿™ä¸ªé˜¶æ®µå‡†å¤‡æœ¬å¸§éœ€è¦æ¸²æŸ“çš„é¡µé¢ï¼ŒåŒ…å«5ä¸ªæ­¥éª¤ï¼š

#### Step 1: é‡Šæ”¾å¤±æ•ˆé¡µé¢ï¼ˆFree Invalidated Pagesï¼‰

**ä»£ç ä½ç½®**ï¼šè¡Œ 180-193
**Compute Shader**ï¼š`VSMFreeInvalidatedPages.compute`

**ç›®çš„**ï¼šæ¸…é™¤å› ä»¥ä¸‹åŸå› å¤±æ•ˆçš„ç¼“å­˜é¡µé¢ï¼š
- ç›¸æœºç§»åŠ¨å¯¼è‡´çº§è”è§†é”¥å¹³ç§»ï¼ˆæ»‘åŠ¨çª—å£æœºåˆ¶ï¼‰
- åŠ¨æ€ç‰©ä½“è¿åŠ¨å¯¼è‡´é˜´å½±å¤±æ•ˆ

**å®ç°ç»†èŠ‚**ï¼š
```cpp
// CPUç«¯è®¡ç®—çº§è”ç§»åŠ¨é‡
Vector2Int cascadeShift = newOffset - oldOffset;

// GPUç«¯æ£€æŸ¥æ˜¯å¦éœ€è¦é‡Šæ”¾
bool shouldClearWrap =
    (cascadeShift.x > 0 && pageCoords.x < cascadeShift.x) ||
    (cascadeShift.x < 0 && pageCoords.x > TABLE_RES + cascadeShift.x - 1) ||
    // yæ–¹å‘åŒç†...

bool shouldClearDynamic = extractBitFromMask(pageCoords, dynamicMask);

if (shouldClearWrap || shouldClearDynamic) {
    VPT[wrappedCoords] = 0; // é‡ç½®ä¸ºæœªåˆ†é…çŠ¶æ€
}
```

#### Step 2: æ ‡è®°å¯è§é¡µé¢ï¼ˆMark Visible Pagesï¼‰

**ä»£ç ä½ç½®**ï¼šè¡Œ 195-227
**Compute Shader**ï¼š`VSMMarkVisiblePages.compute`

**ç›®çš„**ï¼šåˆ†æç›¸æœºæ·±åº¦ç¼“å†²ï¼Œç¡®å®šå“ªäº›VSMé¡µé¢åœ¨å½“å‰è§†è§’å¯è§

**å®ç°æµç¨‹**ï¼š
```hlsl
// 1. è¯»å–æ·±åº¦ç¼“å†²é‡å»ºä¸–ç•Œåæ ‡
float depth = _CameraDepthTexture[screenUV];
float3 worldPos = ReconstructWorldPosition(screenUV, depth);

// 2. é€‰æ‹©çº§è”ï¼ˆä¸¤ç§å¯å‘å¼ï¼‰
int cascadeLevel;
if (usePixelPerfectHeuristic) {
    // å¯å‘å¼1: åƒç´ å®Œç¾ï¼ˆ1:1æ˜ å°„ï¼‰
    level = âŒˆlogâ‚‚(T_screen / T_cascade0)âŒ‰
} else {
    // å¯å‘å¼2: åŸºäºè·ç¦»ï¼ˆæ—‹è½¬ä¸å˜ï¼‰
    level = âŒˆlogâ‚‚(distance / cascadeSize0)âŒ‰
}

// 3. æŠ•å½±åˆ°å…‰ç©ºé—´ï¼Œè®¡ç®—è™šæ‹Ÿé¡µåæ ‡
float2 lightUV = WorldToLightUV(worldPos, cascadeMatrix);
int2 pageCoords = floor(lightUV * PAGE_TABLE_RES);

// 4. ä¸ºPCFæ»¤æ³¢æ ‡è®°å‘¨å›´é¡µé¢
for (dy = -filterMargin; dy <= filterMargin; dy++) {
    for (dx = -filterMargin; dx <= filterMargin; dx++) {
        int2 neighborPage = pageCoords + int2(dx, dy);
        uint pageEntry = VPT[neighborPage];

        if (!IsAllocated(pageEntry)) {
            // è¯·æ±‚åˆ†é…
            _AllocationRequests.Append(neighborPage);
        } else if (!IsVisible(pageEntry)) {
            // æ ‡è®°ä¸ºå¯è§
            InterlockedOr(VPT[neighborPage], VISIBLE_BIT);
        }
    }
}
```

**ä¸¤ç§çº§è”é€‰æ‹©å¯å‘å¼**ï¼š

| å¯å‘å¼ | å…¬å¼ | ä¼˜ç‚¹ | ç¼ºç‚¹ |
|-------|------|------|------|
| åƒç´ å®Œç¾ | level = âŒˆlogâ‚‚(T_w / T_câ‚€)âŒ‰ | ç†è®ºæœ€ä¼˜ï¼Œ1:1æ˜ å°„ | å¯èƒ½é€‰åˆ°è§†é”¥å¤–ï¼Œæ—‹è½¬æ—¶æŠ–åŠ¨ |
| åŸºäºè·ç¦» | level = âŒˆlogâ‚‚(d / s_câ‚€)âŒ‰ | æ—‹è½¬ä¸å˜ï¼Œç¨³å®š | éä¸¥æ ¼1:1æ˜ å°„ |

T_w = å±å¹•åƒç´ ä¸–ç•Œå°ºå¯¸, T_câ‚€ = çº§è”0çº¹ç´ ä¸–ç•Œå°ºå¯¸
d = è·ç›¸æœºè·ç¦», s_câ‚€ = çº§è”0è¾¹é•¿

#### Step 3: å¡«å……åˆ†é…å™¨ç¼“å†²åŒºï¼ˆFill Allocator Buffersï¼‰

**ä»£ç ä½ç½®**ï¼šè¡Œ 229-241
**Compute Shader**ï¼š`VSMAllocatePages.compute` (FillAllocatorBuffers kernel)

**ç›®çš„**ï¼šå°†æ‰€æœ‰ç‰©ç†é¡µé¢åˆ†ç±»åˆ°ä¸¤ä¸ªç¼“å†²åŒºï¼š

```cpp
for (æ¯ä¸ªç‰©ç†é¡µé¢) {
    if (!å·²åˆ†é…) {
        freePages.Append(é¡µé¢); // ç¬¬ä¸€ä¼˜å…ˆçº§ï¼šç©ºé—²é¡µ
    } else {
        if (!å¯¹åº”è™šæ‹Ÿé¡µå¯è§) {
            usedButInvisiblePages.Append(é¡µé¢); // ç¬¬äºŒä¼˜å…ˆçº§ï¼šå¯å¤ç”¨é¡µ
        }
        // å¯è§é¡µä¸åŠ å…¥ä»»ä½•ç¼“å†²åŒºï¼ˆä¿æŒä¸åŠ¨ï¼‰
    }
}
```

**è®ºæ–‡åŸæ–‡**ï¼š
> "The first buffer contains the coordinates of all pages that have not yet been allocated to a VSM page. The second buffer holds the coordinates of all physical pages that have been allocated but are backing virtual pages that were not marked as visible in this frame."

#### Step 4: åˆ†é…é¡µé¢ï¼ˆAllocate Pagesï¼‰

**ä»£ç ä½ç½®**ï¼šè¡Œ 243-280
**Compute Shader**ï¼š`VSMAllocatePages.compute` (AllocatePages kernel)

**ç›®çš„**ï¼šä½¿ç”¨**ä¸¤é˜¶æ®µåˆ†é…ç­–ç•¥**ä¸ºè¯·æ±‚åˆ†é…çš„è™šæ‹Ÿé¡µé¢åˆ†é…ç‰©ç†å†…å­˜

**ä¸¤é˜¶æ®µåˆ†é…ç®—æ³•**ï¼š

```hlsl
// é˜¶æ®µ1: ä¼˜å…ˆä½¿ç”¨å®Œå…¨ç©ºé—²çš„ç‰©ç†é¡µ
uint freeIndex;
InterlockedAdd(_AllocationCounter[0], 1, freeIndex);

if (freeIndex < freePageCount) {
    physicalPage = _FreePages[freeIndex];
    // ç›´æ¥ä½¿ç”¨ï¼Œæ— éœ€é‡Šæ”¾
} else {
    // é˜¶æ®µ2: ç©ºé—²é¡µä¸è¶³ï¼Œå¤ç”¨å·²åˆ†é…ä½†ä¸å¯è§çš„é¡µ
    uint usedIndex;
    InterlockedAdd(_AllocationCounter[1], 1, usedIndex);

    if (usedIndex < usedPageCount) {
        physicalPage = _UsedPages[usedIndex];

        // å…³é”®ï¼šå…ˆé‡Šæ”¾æ—§çš„è™šæ‹Ÿé¡µæ˜ å°„
        int3 oldVirtualPage = PPT[physicalPage].xyz;
        VPT[oldVirtualPage] = 0; // é‡ç½®æ—§è™šæ‹Ÿé¡µ
    }
}

// å»ºç«‹æ–°æ˜ å°„
VPT[virtualPage] = PackEntry(true, true, true, physicalPage);
PPT[physicalPage] = (virtualPage, 1);
```

**è®ºæ–‡å¼ºè°ƒ**ï¼š
> "The allocator attempts to use physical pages from the first buffer, holding unallocated pages. Only when there are insufficient free pages are the pages in the second buffer used. [...] the page must first be freed before it is reused."

#### Step 5: æ¸…é™¤è„é¡µé¢ï¼ˆClear Dirty Pagesï¼‰

**ä»£ç ä½ç½®**ï¼šè¡Œ 282-305
**Compute Shader**ï¼š`VSMClearPages.compute`

**ç›®çš„**ï¼šå°†æ–°åˆ†é…çš„ç‰©ç†é¡µé¢æ¸…é›¶ï¼ˆæ·±åº¦è®¾ä¸º1.0 = æ— ç©·è¿œï¼‰

```hlsl
// éå†æ‰€æœ‰åˆ†é…è¯·æ±‚
for (æ¯ä¸ªåˆ†é…è¯·æ±‚) {
    uint pageEntry = VPT[virtualPage];
    if (!IsAllocated(pageEntry)) continue;

    int2 physicalPage = UnpackPhysicalCoords(pageEntry);

    // æ¸…é™¤æ•´ä¸ªç‰©ç†é¡µï¼ˆ128Ã—128ï¼‰
    for (y = 0; y < PAGE_SIZE; y++) {
        for (x = 0; x < PAGE_SIZE; x++) {
            int2 texel = physicalPage * PAGE_SIZE + int2(x, y);
            _PhysicalMemory[texel] = 1.0; // è¿œå¹³é¢
        }
    }
}
```

ä½¿ç”¨é—´æ¥è°ƒåº¦ï¼ˆIndirect Dispatchï¼‰æé«˜æ•ˆç‡ã€‚

#### Step 6: æ„å»ºå±‚çº§é¡µé¢ç¼“å†²ï¼ˆBuild HPBï¼‰

**ä»£ç ä½ç½®**ï¼šè¡Œ 310
**ç±»æ–¹æ³•**ï¼š`VSMHierarchicalPageBuffer.cs:52-80`
**Compute Shader**ï¼š`VSMBuildHPB.compute`

**ç›®çš„**ï¼šæ„å»ºç”¨äºå‡ ä½•å‰”é™¤çš„åŠ é€Ÿç»“æ„ï¼ˆç±»ä¼¼Hi-Zï¼Œä½†å­˜å‚¨dirtyæ ‡å¿—ï¼‰

**æ„å»ºæµç¨‹**ï¼š

```hlsl
// Level 0: ä»VPTæå–dirtyæ ‡å¿—
if (mipLevel == 0) {
    uint pageEntry = VPT[pageCoords];
    dirtyValue = GetIsDirty(pageEntry) ? 1.0 : 0.0;
}
// Level N: 2Ã—2 max reduction
else {
    int2 srcCoord = dstCoord * 2;
    float v00 = HPB[mipLevel-1][srcCoord + (0,0)];
    float v01 = HPB[mipLevel-1][srcCoord + (1,0)];
    float v10 = HPB[mipLevel-1][srcCoord + (0,1)];
    float v11 = HPB[mipLevel-1][srcCoord + (1,1)];
    dirtyValue = max(max(v00,v01), max(v10,v11));
}
HPB[mipLevel][dstCoord] = dirtyValue;
```

**Mipé“¾ç»“æ„**ï¼š
```
Level 0: 32Ã—32 (åŸå§‹åˆ†è¾¨ç‡)
Level 1: 16Ã—16
Level 2: 8Ã—8
Level 3: 4Ã—4
Level 4: 2Ã—2
Level 5: 1Ã—1
```

---

### é˜¶æ®µäºŒï¼šDrawingï¼ˆç»˜åˆ¶/çƒ˜ç„™é˜¶æ®µï¼‰â­

**ä½ç½®**ï¼š`VirtualShadowMapManager.cs:320-384`

**è¿™æ˜¯æ ¸å¿ƒçš„é˜´å½±æ·±åº¦çƒ˜ç„™ä»£ç ï¼**

#### ä¸»æµç¨‹å®ç°

```csharp
void DrawingPhase()
{
    // 1. åˆå§‹åŒ–CommandBuffer
    vsmCommandBuffer.Clear();

    // 2. è®¾ç½®å…¨å±€Shaderå‚æ•°
    vsmCommandBuffer.SetGlobalTexture("_VirtualPageTable", pageTable.VPT);
    vsmCommandBuffer.SetGlobalTexture("_PhysicalMemory", physicalMemory.Texture);
    vsmCommandBuffer.SetGlobalBuffer("_CascadeLightMatrices", cascadeMatrices);
    vsmCommandBuffer.SetGlobalBuffer("_CascadeOffsets", cascadeOffsets);

    // 3. è·å–æ‰€æœ‰é˜´å½±æŠ•å°„ç‰©
    Renderer[] renderers = FindObjectsOfType<Renderer>();

    // 4. éå†16ä¸ªçº§è”
    for (int cascade = 0; cascade < 16; cascade++)
    {
        vsmCommandBuffer.SetGlobalInt("_CurrentCascade", cascade);

        foreach (Renderer renderer in renderers)
        {
            // a. å±‚çº§è¿‡æ»¤
            if (!IsShadowCaster(renderer)) continue;

            // b. è§†é”¥å‰”é™¤
            if (!IsInCascadeFrustum(renderer.bounds, cascade))
                continue;

            // c. HPBå‰”é™¤ï¼ˆå¯é€‰ï¼Œé«˜çº§ä¼˜åŒ–ï¼‰
            if (useHPBCulling && !PassHPBCull(renderer, cascade))
                continue;

            // d. è®°å½•ç»˜åˆ¶å‘½ä»¤
            vsmCommandBuffer.DrawMesh(
                mesh,
                worldMatrix,
                vsmDepthMaterial,
                submeshIndex: 0,
                shaderPass: 0
            );
        }
    }

    // 5. æ‰§è¡Œæ‰€æœ‰ç»˜åˆ¶å‘½ä»¤
    Graphics.ExecuteCommandBuffer(vsmCommandBuffer);
}
```

#### è§†é”¥å‰”é™¤å®ç°

**ä½ç½®**ï¼š`VirtualShadowMapManager.cs:386-421`

```csharp
bool IsInCascadeFrustum(Bounds bounds, int cascadeIndex)
{
    Matrix4x4 lightMatrix = cascadeLightMatrices[cascadeIndex];

    // æ£€æŸ¥AABBçš„8ä¸ªé¡¶ç‚¹
    for (int i = 0; i < 8; i++)
    {
        Vector3 corner = bounds.center + ExtractCorner(bounds.extents, i);
        Vector4 lightSpace = lightMatrix * new Vector4(corner, 1);
        Vector3 ndc = lightSpace.xyz / lightSpace.w;

        // å¦‚æœä»»ä¸€é¡¶ç‚¹åœ¨NDCç«‹æ–¹ä½“å†… [-1,1]Â³
        if (IsInNDCCube(ndc))
            return true;
    }
    return false;
}
```

#### VSMæ·±åº¦Shader

**ä½ç½®**ï¼š`Assets/Shaders/VSM/VSMDepthRender.shader:67-115`

**Fragment Shaderæ ¸å¿ƒä»£ç **ï¼š

```hlsl
void frag(v2f i, out float depth : SV_Depth)
{
    // 1. è®¡ç®—è™šæ‹Ÿçº¹ç†åæ ‡ï¼ˆè®ºæ–‡Listing 12.3ï¼‰
    int2 virtualTexel = int2(i.pos.xy); // gl_FragCoord.xy
    float2 virtualUV = virtualTexel / float(4096);

    // 2. è®¡ç®—è™šæ‹Ÿé¡µåæ ‡
    int3 pageCoords = int3(
        floor(virtualUV * 32), // PAGE_TABLE_RESOLUTION
        i.cascadeIndex
    );

    // 3. è½¬æ¢ä¸ºç¯å½¢ç¼“å†²åæ ‡
    int2 cascadeOffset = _CascadeOffsets[i.cascadeIndex];
    int3 wrappedCoords = VirtualPageToWrapped(pageCoords, cascadeOffset);

    if (wrappedCoords.x < 0) discard;

    // 4. æŸ¥æ‰¾é¡µè¡¨
    uint pageEntry = _VirtualPageTable[wrappedCoords];

    // 5. åªå†™å…¥å·²åˆ†é…ä¸”è„çš„é¡µé¢
    if (!GetIsAllocated(pageEntry) || !GetIsDirty(pageEntry))
        discard;

    // 6. è®¡ç®—ç‰©ç†å†…å­˜åæ ‡
    int2 physicalPage = UnpackPhysicalCoords(pageEntry);
    int2 inPageOffset = virtualTexel % 128; // PAGE_SIZE
    int2 physicalTexel = physicalPage * 128 + inPageOffset;

    // 7. åŸå­å†™å…¥æ·±åº¦ï¼ˆè®ºæ–‡å…³é”®ï¼ï¼‰
    float fragmentDepth = i.pos.z; // gl_FragCoord.z
    InterlockedMin(_PhysicalMemory[physicalTexel], asuint(fragmentDepth));

    // 8. è¾“å‡ºæ·±åº¦åˆ°æ·±åº¦ç¼“å†²
    depth = fragmentDepth;
}
```

**å…³é”®ç‚¹**ï¼š
1. ä½¿ç”¨ `i.pos.z`ï¼ˆç¡¬ä»¶æ’å€¼æ·±åº¦ï¼‰è€Œévertex shaderä¼ é€’çš„æ·±åº¦
2. ä½¿ç”¨ `InterlockedMin` ä¿è¯å¤šé‡é‡‡æ ·æ­£ç¡®æ€§
3. åªæ¸²æŸ“è„é¡µé¢ï¼Œè·³è¿‡ç¼“å­˜é¡µé¢

#### HPBå‰”é™¤ç®—æ³•ï¼ˆå¯é€‰é«˜çº§ä¼˜åŒ–ï¼‰

**ä½ç½®**ï¼š`Assets/Shaders/Include/VSMCommon.hlsl:139-170`

```hlsl
bool HPBCullTest(Bounds bounds, int cascade, Texture2DArray HPB)
{
    // 1. æŠ•å½±åŒ…å›´ç›’åˆ°å…‰ç©ºé—´
    float2 uvMin, uvMax;
    ProjectBoundsToLightSpace(bounds, cascadeMatrix, uvMin, uvMax);

    // 2. é€‰æ‹©åˆé€‚çš„mip levelï¼ˆè®ºæ–‡ï¼šæ­£å¥½è¦†ç›–4ä¸ªtexelï¼‰
    float2 texelSize = (uvMax - uvMin) * PAGE_TABLE_RES;
    int mipLevel = floor(log2(max(texelSize.x, texelSize.y) / 2.0));
    mipLevel = clamp(mipLevel, 0, HPB_MAX_LEVEL);

    // 3. è®¡ç®—è¯¥mipä¸‹çš„texelèŒƒå›´
    int resolution = PAGE_TABLE_RES >> mipLevel;
    int2 texelMin = floor(uvMin * resolution);
    int2 texelMax = ceil(uvMax * resolution);

    // 4. æ£€æŸ¥æ‰€æœ‰ç›¸äº¤texelçš„dirtyæ ‡å¿—
    for (int y = texelMin.y; y <= texelMax.y; y++) {
        for (int x = texelMin.x; x <= texelMax.x; x++) {
            if (HPB[int3(x, y, cascade)] > 0.5) {
                return true; // è‡³å°‘ä¸€ä¸ªtexelæ˜¯dirtyï¼Œé€šè¿‡å‰”é™¤
            }
        }
    }

    return false; // æ‰€æœ‰texeléƒ½ä¸æ˜¯dirtyï¼Œå‰”é™¤è¯¥å‡ ä½•ä½“
}
```

**è®ºæ–‡åŸæ–‡**ï¼š
> "When culling geometry against the HPB, we follow a process almost identical to culling against a Hi-Z. [...] we select the level in which the bounding-box bounds intersect exactly four texels. Lastly, if any of the four intersected texels is marked as dirty, the meshlet survives culling; otherwise, it is discarded."

---

### é˜¶æ®µä¸‰ï¼šSamplingï¼ˆé‡‡æ ·é˜¶æ®µï¼‰

**ä½ç½®**ï¼š`Assets/Shaders/VSM/VSMSampling.hlsl`

åœ¨ä¸»åœºæ™¯æ¸²æŸ“æ—¶ï¼Œæè´¨è°ƒç”¨VSMé‡‡æ ·å‡½æ•°è·å–é˜´å½±ã€‚

#### åŸºç¡€é‡‡æ ·å‡½æ•°

```hlsl
float SampleVSM(float3 worldPos, float bias = 0.001)
{
    // 1. é€‰æ‹©çº§è”
    int cascade = CalculateCascadeLevel(worldPos, cameraPos, cascade0Size);

    // 2. è½¬æ¢åˆ°å…‰ç©ºé—´
    float4x4 lightMatrix = _VSM_CascadeLightMatrices[cascade];
    float4 lightSpacePos = mul(lightMatrix, float4(worldPos, 1.0));
    float2 lightUV = lightSpacePos.xy * 0.5 + 0.5;

    // 3. è®¡ç®—è™šæ‹Ÿé¡µåæ ‡
    int3 pageCoords = int3(floor(lightUV * 32), cascade);

    // 4. ç¯å½¢ç¼“å†²è½¬æ¢
    int2 offset = _VSM_CascadeOffsets[cascade];
    int3 wrappedCoords = VirtualPageToWrapped(pageCoords, offset);

    if (wrappedCoords.x < 0) return 1.0; // ä¸åœ¨èŒƒå›´å†…ï¼Œæ— é˜´å½±

    // 5. æŸ¥æ‰¾é¡µè¡¨
    uint pageEntry = _VSM_VirtualPageTable[wrappedCoords];
    if (!GetIsAllocated(pageEntry)) return 1.0; // é¡µé¢æœªåˆ†é…

    // 6. è·å–ç‰©ç†é¡µåæ ‡
    int2 physicalPage = UnpackPhysicalCoords(pageEntry);

    // 7. è®¡ç®—é¡µå†…UV
    float2 pageUV = frac(lightUV * 32);

    // 8. è®¡ç®—ç‰©ç†çº¹ç†UV
    float2 physicalUV = (physicalPage + pageUV) * 128 / float2(8192, 4096);

    // 9. é‡‡æ ·ç‰©ç†å†…å­˜
    float shadowDepth = _VSM_PhysicalMemory.SampleLevel(sampler, physicalUV, 0);

    // 10. æ·±åº¦æ¯”è¾ƒ
    float currentDepth = lightSpacePos.z;
    return (currentDepth - bias) > shadowDepth ? 0.0 : 1.0;
}
```

#### PCFæ»¤æ³¢é‡‡æ ·

```hlsl
float SampleVSM_PCF(float3 worldPos, float filterSize = 2.0)
{
    // ... å‰é¢æ­¥éª¤ç›¸åŒ ...

    float shadow = 0.0;
    float weight = 0.0;

    // 3Ã—3 PCFæ ¸
    for (int dy = -1; dy <= 1; dy++) {
        for (int dx = -1; dx <= 1; dx++) {
            float2 offset = float2(dx, dy) * texelSize * filterSize;
            float2 sampleUV = lightUV + offset;

            // å¯¹æ¯ä¸ªé‡‡æ ·é‡å¤è™šæ‹Ÿâ†’ç‰©ç†æ˜ å°„æµç¨‹
            int3 samplePage = CalculatePageCoords(sampleUV, cascade);
            // ... å®Œæ•´çš„é¡µè¡¨æŸ¥æ‰¾ ...

            float depth = _VSM_PhysicalMemory.Sample(sampler, physicalUV);
            shadow += CompareDepth(currentDepth, depth, bias);
            weight += 1.0;
        }
    }

    return weight > 0 ? shadow / weight : 1.0;
}
```

**ä¸ºä½•PCFéœ€è¦filterMarginï¼Ÿ**

è®ºæ–‡12.2.3èŠ‚æŒ‡å‡ºï¼š
> "When filtering, this assumption is broken. One or more samples from the filtering region may fall into parts of the world that are not visible from the main camera. [...] To mitigate the issue [...] the Mark Visible Pages pass must be modified. Instead of marking only the page directly corresponding to the visible texel, we mark all pages lying in a region around it."

è§£å†³æ–¹æ¡ˆï¼šåœ¨Step 2ä¸­ä¸ä»…æ ‡è®°åƒç´ å¯¹åº”çš„é¡µé¢ï¼Œè¿˜æ ‡è®°å‘¨å›´çš„é¡µé¢ï¼ˆfilterMarginå‚æ•°ï¼‰ã€‚

---

## å…³é”®ç®—æ³•è¯¦è§£

### 1. ä¸¤ç§çº§è”é€‰æ‹©å¯å‘å¼å¯¹æ¯”

#### å¯å‘å¼1ï¼šåƒç´ å®Œç¾ï¼ˆPixel-Perfectï¼‰

**å…¬å¼**ï¼š`level = max(âŒˆlogâ‚‚(T_w / T_câ‚€)âŒ‰, 0)`

**åŸç†**ï¼šè¿½æ±‚å±å¹•åƒç´ ä¸é˜´å½±çº¹ç´ çš„1:1æ˜ å°„

**ä¼˜ç‚¹**ï¼š
- ç†è®ºæœ€ä¼˜ç»†èŠ‚åˆ†é…
- ä¸æµªè´¹é˜´å½±åˆ†è¾¨ç‡

**ç¼ºç‚¹**ï¼š
- ç›¸æœºæ—‹è½¬æ—¶çº§è”åˆ‡æ¢é¢‘ç¹ï¼ˆæŠ–åŠ¨ï¼‰
- å¯èƒ½é€‰ä¸­è§†é”¥å¤–çš„çº§è”
- éœ€è¦åç½®ï¼ˆbiasï¼‰è°ƒæ•´

**ä½¿ç”¨åœºæ™¯**ï¼šé™æ€æˆ–æ…¢é€Ÿæ—‹è½¬çš„ç›¸æœº

**å®ç°**ï¼š
```hlsl
// è®¡ç®—å±å¹•åƒç´ çš„ä¸–ç•Œå°ºå¯¸
float GetScreenTexelWorldSize(float3 worldPos) {
    float4 clipPos = mul(viewProj, float4(worldPos, 1));
    float4 clipPosOffset = clipPos + float4(2.0/screenWidth, 0, 0, 0);

    float3 worldPos2 = UnprojectToWorld(clipPosOffset);
    return length(worldPos2 - worldPos);
}

// å¯å‘å¼1
int level = ceil(log2(GetScreenTexelWorldSize(pos) / cascade0TexelSize));
```

#### å¯å‘å¼2ï¼šåŸºäºè·ç¦»ï¼ˆDistance-Basedï¼‰

**å…¬å¼**ï¼š`level = max(âŒˆlogâ‚‚(d / s_câ‚€)âŒ‰, 0)`

**åŸç†**ï¼šæ ¹æ®è·ç›¸æœºè·ç¦»é€‰æ‹©çº§è”

**ä¼˜ç‚¹**ï¼š
- **æ—‹è½¬ä¸å˜æ€§** - ç›¸æœºæ—‹è½¬æ—¶çº§è”ä¿æŒç¨³å®š
- å®ç°ç®€å•
- ä¸ä¼šé€‰åˆ°è§†é”¥å¤–

**ç¼ºç‚¹**ï¼š
- éä¸¥æ ¼1:1æ˜ å°„
- å¯èƒ½åœ¨æŸäº›è§’åº¦è¿‡é‡‡æ ·æˆ–æ¬ é‡‡æ ·

**ä½¿ç”¨åœºæ™¯**ï¼šè‡ªç”±è§†è§’æ¸¸æˆã€FPS

**å®ç°**ï¼š
```hlsl
float distance = length(worldPos - cameraPos);
int level = ceil(log2(distance / firstCascadeSize));
```

**è®ºæ–‡æ€»ç»“**ï¼š
> "Although this heuristic has a theoretically optimal cascade selection, it does not take into account the available resolution of each cascade. [...] An advantage of this heuristic is that the chosen level for a given location in world space is rotationally invariant."

### 2. å…‰æºä½ç½®å¹³é¢çº¦æŸ

**ç›®çš„**ï¼šä¿è¯ç¼“å­˜é¡µé¢çš„æ·±åº¦å€¼åœ¨å…‰æºç§»åŠ¨æ—¶ä»ç„¶æœ‰æ•ˆ

**è®ºæ–‡è¦æ±‚**ï¼š
> "the light position is constrained so that, when modified, it slides along a plane parallel to the near-plane of the respective light matrix. This constraint is necessary for the depth stored in cached pages to remain valid even after translating the light matrix."

**å®ç°åŸç†**ï¼š

```
        å…‰æºç§»åŠ¨æ–¹å‘
              â†“
    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€  â† å¹³è¡Œäºnear-planeçš„çº¦æŸå¹³é¢
         â•‘   â•‘   â•‘
         â•‘   â•‘   â•‘      å…‰çº¿æ–¹å‘ï¼ˆå‚ç›´äºå¹³é¢ï¼‰
         â–¼   â–¼   â–¼

    åœºæ™¯ç‰©ä½“ï¼ˆæ·±åº¦å€¼ä¿æŒä¸å˜ï¼‰
```

**ä»£ç å®ç°**ï¼š
```csharp
// 1. è®¡ç®—å…‰æºè§†å›¾çš„rightå’Œupå‘é‡ï¼ˆå¹³é¢åŸºå‘é‡ï¼‰
Vector3 lightDir = directionalLight.forward;
Vector3 right = Vector3.Cross(lightDir, Vector3.up).normalized;
Vector3 up = Vector3.Cross(right, lightDir).normalized;

// 2. åˆå§‹å…‰æºä½ç½®
Vector3 lightPos = snappedCameraPos - lightDir * cascadeSize;

// 3. æŠ•å½±åˆ°çº¦æŸå¹³é¢å¹¶å¯¹é½ç½‘æ ¼
float rightOffset = Vector3.Dot(lightPos, right);
float upOffset = Vector3.Dot(lightPos, up);
rightOffset = Mathf.Floor(rightOffset / pageWorldSize) * pageWorldSize;
upOffset = Mathf.Floor(upOffset / pageWorldSize) * pageWorldSize;

// 4. é‡å»ºçº¦æŸåçš„å…‰æºä½ç½®
float depthOffset = Vector3.Dot(lightPos, lightDir);
lightPos = right * rightOffset + up * upOffset + lightDir * depthOffset;
```

**æ•ˆæœ**ï¼šå…‰æºåªèƒ½åœ¨å‚ç›´äºå…‰çº¿æ–¹å‘çš„å¹³é¢ä¸Šç§»åŠ¨ï¼Œæ·±åº¦æ–¹å‘ä¿æŒå›ºå®šï¼Œç¼“å­˜é¡µé¢æ·±åº¦å€¼å§‹ç»ˆæœ‰æ•ˆã€‚

### 3. æ»‘åŠ¨çª—å£ï¼ˆ2D Wraparound Addressingï¼‰

**é—®é¢˜**ï¼šç›¸æœºç§»åŠ¨æ—¶ï¼Œæ–°é¡µé¢è¿›å…¥è§†é‡ï¼Œæ—§é¡µé¢é€€å‡º

**ä¼ ç»Ÿæ–¹æ¡ˆ**ï¼šæ¸…ç©ºå¹¶é‡æ–°åˆ†é…æ‰€æœ‰é¡µé¢ âŒ

**VSMæ–¹æ¡ˆ**ï¼šç¯å½¢ç¼“å†²ï¼Œæ–°é¡µé¢å¤ç”¨æ—§é¡µé¢çš„VPTä½ç½® âœ…

**ç¤ºæ„å›¾**ï¼š
```
ç›¸æœºå‘å³ç§»åŠ¨ï¼š

æ—§è§†é‡ï¼š          æ–°è§†é‡ï¼š
â”Œâ”€â”¬â”€â”¬â”€â”¬â”€â”        â”Œâ”€â”¬â”€â”¬â”€â”¬â”€â”
â”‚Aâ”‚Bâ”‚Câ”‚Dâ”‚        â”‚ â”‚Bâ”‚Câ”‚Dâ”‚Eâ”‚
â”œâ”€â”¼â”€â”¼â”€â”¼â”€â”¤   â†’    â”œâ”€â”¼â”€â”¼â”€â”¼â”€â”¤
â”‚Eâ”‚Fâ”‚Gâ”‚Hâ”‚        â”‚ â”‚Fâ”‚Gâ”‚Hâ”‚Iâ”‚
â””â”€â”´â”€â”´â”€â”´â”€â”˜        â””â”€â”´â”€â”´â”€â”´â”€â”˜
é€€å‡ºâ†        â†’è¿›å…¥

VPTå¤ç”¨ï¼š
Açš„ä½ç½® â†’ å­˜å‚¨Eçš„æ•°æ®
Eçš„ä½ç½® â†’ å­˜å‚¨Içš„æ•°æ®
```

**å®ç°**ï¼š
```hlsl
int2 VirtualPageToWrapped(int2 pageCoords, int2 cascadeOffset) {
    int2 offsetCoords = pageCoords + cascadeOffset;
    int2 wrapped = offsetCoords % PAGE_TABLE_RESOLUTION;

    // å¤„ç†è´Ÿæ•°æ¨¡è¿ç®—
    if (wrapped.x < 0) wrapped.x += PAGE_TABLE_RESOLUTION;
    if (wrapped.y < 0) wrapped.y += PAGE_TABLE_RESOLUTION;

    return wrapped;
}
```

**ä¼˜ç‚¹**ï¼š
- ä¿ç•™å¤§éƒ¨åˆ†ç¼“å­˜é¡µé¢
- åªé‡æ–°æ¸²æŸ“è¾¹ç¼˜çš„æ–°é¡µé¢
- é¿å…å…¨å±€åˆ·æ–°

### 4. å±‚çº§é¡µé¢ç¼“å†²ï¼ˆHPBï¼‰å‰”é™¤åŸç†

**ç›®æ ‡**ï¼šé¿å…æ¸²æŸ“ä¸ä¼šå½±å“ä»»ä½•è„é¡µé¢çš„å‡ ä½•ä½“

**ç±»æ¯”**ï¼šHi-Zç”¨æ·±åº¦å€¼å‰”é™¤è¢«é®æŒ¡ç‰©ä½“ï¼ŒHPBç”¨è„æ ‡å¿—å‰”é™¤ä¸å½±å“è„é¡µçš„ç‰©ä½“

**Mipé“¾æ„å»º**ï¼š
```hlsl
// ä¼ªä»£ç 
HPB[0] = ExtractDirtyFlags(VPT);  // 32Ã—32

for (level = 1; level < maxLevel; level++) {
    for (æ¯ä¸ªtexel in HPB[level]) {
        // 2Ã—2 max reduction
        float4 children = SampleChildren(HPB[level-1]);
        HPB[level][texel] = max(max(children.x, children.y),
                                 max(children.z, children.w));
    }
}
```

**å‰”é™¤æµ‹è¯•**ï¼š
```
1. é¡¹ç›®åŒ…å›´ç›’ â†’ å…‰ç©ºé—´UVèŒƒå›´ [uvMin, uvMax]

2. é€‰æ‹©mip level:
   - è®¡ç®—UVèŒƒå›´è¦†ç›–çš„texelæ•°é‡
   - é€‰æ‹©è®©åŒ…å›´ç›’æ­£å¥½è¦†ç›–â‰ˆ4ä¸ªtexelçš„level

3. è¯»å–è¿™4ä¸ªï¼ˆæˆ–æ›´å¤šï¼‰texelçš„dirtyå€¼

4. åˆ¤æ–­ï¼š
   - ä»»ä¸€texel == 1.0 â†’ é€šè¿‡å‰”é™¤ï¼ˆéœ€è¦æ¸²æŸ“ï¼‰
   - å…¨éƒ¨texel == 0.0 â†’ è¢«å‰”é™¤ï¼ˆè·³è¿‡æ¸²æŸ“ï¼‰
```

**æ•ˆç‡åˆ†æ**ï¼š
- ä¼ ç»Ÿï¼šæ¸²æŸ“æ‰€æœ‰16ä¸ªçº§è”çš„æ‰€æœ‰å‡ ä½• â‰ˆ 16Næ¬¡drawcall
- HPBå‰”é™¤ï¼šåªæ¸²æŸ“å½±å“è„é¡µçš„å‡ ä½• â‰ˆ 0.1N ~ 2Næ¬¡drawcallï¼ˆå–å†³äºç¼“å­˜ç‡ï¼‰

---

## æ•°æ®ç»“æ„è®¾è®¡

### è™šæ‹Ÿé¡µè¡¨ï¼ˆVPTï¼‰æ¡ç›®æ ¼å¼

**32ä½æ‰“åŒ…ç»“æ„**ï¼š

```
Bit 31      25 24      14 13     3  2  1  0
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”¬â”€â”€â”¬â”€â”€â”
â”‚ PhysY     â”‚  PhysX    â”‚ (ä¿ç•™) â”‚D â”‚V â”‚A â”‚
â”‚ (11 bits) â”‚ (11 bits) â”‚        â”‚  â”‚  â”‚  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”´â”€â”€â”´â”€â”€â”˜
                                    â”‚  â”‚  â””â”€ Allocated (å·²åˆ†é…)
                                    â”‚  â””â”€â”€â”€â”€ Visible (å¯è§)
                                    â””â”€â”€â”€â”€â”€â”€â”€ Dirty (è„)
```

**ç¼–è§£ç å‡½æ•°**ï¼š
```hlsl
// ç¼–ç 
uint PackPageEntry(bool allocated, bool visible, bool dirty, int2 physicalCoords)
{
    uint result = 0;
    if (allocated) result |= 0x1u;
    if (visible)   result |= 0x2u;
    if (dirty)     result |= 0x4u;
    result |= (physicalCoords.x & 0x7FFu) << 3;
    result |= (physicalCoords.y & 0x7FFu) << 14;
    return result;
}

// è§£ç 
int2 UnpackPhysicalPageCoords(uint entry)
{
    int x = (entry >> 3) & 0x7FFu;
    int y = (entry >> 14) & 0x7FFu;
    return int2(x, y);
}

bool GetIsAllocated(uint entry) { return (entry & 0x1u) != 0; }
bool GetIsVisible(uint entry)   { return (entry & 0x2u) != 0; }
bool GetIsDirty(uint entry)     { return (entry & 0x4u) != 0; }
```

### ç‰©ç†å†…å­˜å¸ƒå±€

**çº¹ç†æ ¼å¼**ï¼š8192Ã—4096ï¼ŒR32_Float

**é¡µé¢æ’åˆ—**ï¼š

```
ç‰©ç†å†…å­˜ (8192Ã—4096)
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ é¡µ0   é¡µ1   é¡µ2   ...   é¡µ62  é¡µ63        â”‚ â† è¡Œ0 (64é¡µ)
â”‚128Ã—128 ...                                â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ é¡µ64  é¡µ65  é¡µ66  ...   é¡µ126 é¡µ127       â”‚ â† è¡Œ1
â”‚                                           â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  ...                                      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ é¡µ1984 ...               é¡µ2047          â”‚ â† è¡Œ31 (æœ€åä¸€è¡Œ)
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

æ€»é¡µæ•° = 64åˆ— Ã— 32è¡Œ = 2048é¡µ
æ¯é¡µ = 128Ã—128 = 16,384åƒç´ 
```

**åæ ‡è½¬æ¢**ï¼š
```hlsl
// ç‰©ç†é¡µç´¢å¼• â†’ 2Dåæ ‡
int2 PhysicalPageIndexToCoords(uint index) {
    return int2(index % 64, index / 64);
}

// 2Dåæ ‡ â†’ ç‰©ç†é¡µç´¢å¼•
uint PhysicalPageCoordsToIndex(int2 coords) {
    return coords.y * 64 + coords.x;
}

// è™šæ‹Ÿçº¹ç´  â†’ ç‰©ç†çº¹ç´ 
int2 VirtualTexelToPhysical(int2 virtualTexel, int2 physicalPage) {
    int2 inPageOffset = virtualTexel % 128;
    return physicalPage * 128 + inPageOffset;
}
```

### ç¼“å†²åŒºè¯¦ç»†è®¾è®¡

#### åˆ†é…è¯·æ±‚ç¼“å†²ï¼ˆAllocationRequestsï¼‰
```cpp
struct AllocationRequest {
    int3 pageCoords;  // (x, y, cascadeIndex)
    uint padding;     // å¯¹é½åˆ°16å­—èŠ‚
};

ComputeBuffer allocationRequests = new ComputeBuffer(
    32 * 32 * 16,           // æœ€å¤§è¯·æ±‚æ•° = æ‰€æœ‰è™šæ‹Ÿé¡µ
    sizeof(uint) * 4,        // 16å­—èŠ‚/è¯·æ±‚
    ComputeBufferType.Append
);
```

#### ç‰©ç†é¡µç¼“å†²ï¼ˆFreePages & UsedPagesï¼‰
```cpp
struct PhysicalPageCoords {
    int2 coords;  // (åˆ—, è¡Œ)
};

ComputeBuffer freePages = new ComputeBuffer(
    2048,                    // æœ€å¤§ç‰©ç†é¡µæ•°
    sizeof(uint) * 2,        // 8å­—èŠ‚/é¡µ
    ComputeBufferType.Append
);

ComputeBuffer usedPages = new ComputeBuffer(
    2048,
    sizeof(uint) * 2,
    ComputeBufferType.Append
);
```

#### ç‰©ç†é¡µè¡¨ï¼ˆPPTï¼‰
```cpp
struct PhysicalPageTableEntry {
    int3 virtualPageCoords;  // åå‘æ˜ å°„
    uint flags;              // çŠ¶æ€æ ‡å¿—
};

ComputeBuffer physicalPageTable = new ComputeBuffer(
    2048,
    sizeof(uint) * 4,  // 16å­—èŠ‚/æ¡ç›®
    ComputeBufferType.Default
);
```

---

## Shaderå®ç°ç»†èŠ‚

### Compute Shaderæ‰§è¡Œé…ç½®

#### çº¿ç¨‹ç»„å¤§å°é€‰æ‹©

```hlsl
// é¡µè¡¨ç›¸å…³ï¼ˆ32Ã—32ï¼‰
[numthreads(8, 8, 1)]  // è¦†ç›–32Ã—32éœ€è¦ 4Ã—4 = 16ä¸ªçº¿ç¨‹ç»„

// ç‰©ç†é¡µç›¸å…³ï¼ˆ64Ã—32 = 2048ï¼‰
[numthreads(64, 1, 1)]  // çº¿æ€§å¤„ç†ï¼Œ32ä¸ªçº¿ç¨‹ç»„

// å±å¹•åˆ†æï¼ˆ1920Ã—1080ï¼‰
[numthreads(8, 8, 1)]  // éœ€è¦ 240Ã—135 = 32,400ä¸ªçº¿ç¨‹ç»„
```

#### é—´æ¥è°ƒåº¦ï¼ˆIndirect Dispatchï¼‰

**ç”¨é€”**ï¼šæ ¹æ®è¿è¡Œæ—¶æ•°æ®åŠ¨æ€ç¡®å®šçº¿ç¨‹ç»„æ•°é‡

```cpp
// CPUç«¯å‡†å¤‡é—´æ¥å‚æ•°
ComputeBuffer indirectArgs = new ComputeBuffer(3, sizeof(uint));
ComputeBuffer.CopyCount(allocationRequests, indirectArgs, 0);

uint[] args = new uint[3];
indirectArgs.GetData(args);
args[0] = (args[0] + 63) / 64;  // X = ceil(count / 64)
args[1] = 1;
args[2] = 1;
indirectArgs.SetData(args);

// GPUç«¯æ‰§è¡Œ
computeShader.DispatchIndirect(kernel, indirectArgs);
```

### åŸå­æ“ä½œä½¿ç”¨

#### InterlockedMinç”¨äºæ·±åº¦å†™å…¥

**ä¸ºä»€ä¹ˆä¸ç›´æ¥å†™å…¥ï¼Ÿ**

```hlsl
// âŒ é”™è¯¯ï¼šå¤šä¸ªfragmentå¯èƒ½å†™å…¥åŒä¸€åƒç´ 
_PhysicalMemory[texel] = depth;

// âœ… æ­£ç¡®ï¼šåŸå­minä¿è¯å–æœ€å°æ·±åº¦
InterlockedMin(_PhysicalMemory[texel], asuint(depth));
```

**åœºæ™¯**ï¼š
1. ä¸‰è§’å½¢è¾¹ç¼˜é‡å 
2. Alphaæµ‹è¯•å‡ ä½•ï¼ˆè‰ã€å¶å­ï¼‰
3. å¤šå±‚å‡ ä½•ï¼ˆå¤´å‘ã€ç²’å­ï¼‰

**æ·±åº¦æ ¼å¼è½¬æ¢**ï¼š
```hlsl
// float â†’ uint (ä¿æŒæ’åº)
uint depthUint = asuint(depthFloat);

// uint â†’ float (è¯»å–æ—¶)
float depthFloat = asfloat(depthUint);
```

IEEE 754ä¿è¯ï¼šæ­£æµ®ç‚¹æ•°çš„æ•´æ•°è¡¨ç¤ºä¿æŒç›¸åŒé¡ºåºã€‚

#### InterlockedOrç”¨äºæ ‡å¿—è®¾ç½®

```hlsl
// åŸå­è®¾ç½®visibleä½
InterlockedOr(_VirtualPageTable[coords], VSM_VISIBLE_BIT);

// å¤šçº¿ç¨‹å®‰å…¨ï¼Œä¸ä¼šè¦†ç›–å…¶ä»–ä½
```

#### InterlockedAddç”¨äºåˆ†é…è®¡æ•°

```hlsl
uint freeIndex;
InterlockedAdd(_AllocationCounter[0], 1, freeIndex);

if (freeIndex < freePageCount) {
    // å®‰å…¨è·å–å”¯ä¸€çš„ç‰©ç†é¡µ
    PhysicalPage page = _FreePages[freeIndex];
}
```

### çº¹ç†é‡‡æ ·ä¼˜åŒ–

#### Mipmapè€ƒè™‘

VSMç‰©ç†å†…å­˜**ä¸ä½¿ç”¨mipmap**ï¼š
- æ¯ä¸ªçº§è”å·²ç»æ˜¯ä¸åŒç»†èŠ‚å±‚çº§
- ç‰©ç†é¡µä¸è¿ç»­ï¼Œæ— æ³•ç”Ÿæˆæœ‰æ•ˆmipmap
- ä½¿ç”¨`SampleLevel(..., 0)`å¼ºåˆ¶LOD 0

#### æ»¤æ³¢æ¨¡å¼

```cpp
// VPTï¼šå¿…é¡»Pointé‡‡æ ·
virtualPageTable.filterMode = FilterMode.Point;

// ç‰©ç†å†…å­˜ï¼šå¯é€‰Bilinearï¼ˆPCFéœ€è¦ï¼‰
physicalMemory.filterMode = FilterMode.Bilinear;

// HPBï¼šPointé‡‡æ ·ï¼ˆç¦»æ•£dirtyæ ‡å¿—ï¼‰
hpb.filterMode = FilterMode.Point;
```

---

## ä½¿ç”¨æŒ‡å—

### å¿«é€Ÿå¼€å§‹

#### 1. åœºæ™¯è®¾ç½®

```
1. åˆ›å»ºç©ºGameObjectï¼Œå‘½å"VSMManager"
2. æ·»åŠ Cameraç»„ä»¶ï¼ˆä¸»ç›¸æœºï¼‰
3. æ·»åŠ VirtualShadowMapManagerè„šæœ¬
4. åˆ›å»ºDirectional Light
```

#### 2. Inspectoré…ç½®

**VSM Settings:**
- `Directional Light`: æ‹–å…¥åœºæ™¯ä¸­çš„å¹³è¡Œå…‰
- `First Cascade Size`: 2.0ï¼ˆç¬¬ä¸€çº§è”è¾¹é•¿ï¼Œç±³ï¼‰
- `Shadow Casters`: é€‰æ‹©æŠ•å°„é˜´å½±çš„å±‚çº§
- `Filter Margin`: 1ï¼ˆPCFæ»¤æ³¢è¾¹ç¼˜é¡µæ•°ï¼‰

**Cascade Selection Heuristic:**
- `Use Pixel Perfect Heuristic`: falseï¼ˆè·ç¦»å¯å‘å¼ï¼‰
- `Cascade Bias`: 0ï¼ˆçº§è”åç§»ï¼‰

**Compute Shaders:**ï¼ˆæ‹–å…¥å¯¹åº”shaderï¼‰
- `Free Invalidated Pages Shader`: VSMFreeInvalidatedPages
- `Mark Visible Pages Shader`: VSMMarkVisiblePages
- `Allocate Pages Shader`: VSMAllocatePages
- `Clear Pages Shader`: VSMClearPages
- `Build HPB Shader`: VSMBuildHPB

**Rendering:**
- `VSM Depth Shader`: VSMDepthRender
- `VSM Depth Material`: è‡ªåŠ¨åˆ›å»ºæˆ–æ‰‹åŠ¨æŒ‡å®š

**Debug:**
- `Debug Visualization`: å‹¾é€‰ä»¥æ˜¾ç¤ºè°ƒè¯•ä¿¡æ¯

#### 3. æè´¨è®¾ç½®

åœ¨åœºæ™¯ç‰©ä½“çš„shaderä¸­æ·»åŠ VSMé‡‡æ ·ï¼š

```hlsl
#include "Assets/Shaders/VSM/VSMSampling.hlsl"

// åœ¨fragment shaderä¸­
float3 worldPos = i.worldPos;
float shadow = SampleVSM_PCF(worldPos, 2.0, 0.001);

finalColor.rgb *= shadow; // åº”ç”¨é˜´å½±
```

#### 4. è¿è¡Œæµ‹è¯•

1. è¿›å…¥Playæ¨¡å¼
2. ç§»åŠ¨ä¸»ç›¸æœºï¼Œè§‚å¯Ÿé˜´å½±æ›´æ–°
3. å¼€å¯Debugå¯è§†åŒ–æŸ¥çœ‹çŠ¶æ€

### å‚æ•°è°ƒä¼˜æŒ‡å—

#### First Cascade Sizeï¼ˆç¬¬ä¸€çº§è”å°ºå¯¸ï¼‰

**å½±å“**ï¼šæ‰€æœ‰çº§è”çš„åŸºç¡€åˆ†è¾¨ç‡

```
çº§è”0: firstCascadeSize = 2m
  â†’ è™šæ‹Ÿåˆ†è¾¨ç‡ 4096Ã—4096
  â†’ çº¹ç´ ä¸–ç•Œå°ºå¯¸ = 2m / 4096 â‰ˆ 0.5mm/texel

çº§è”1: 4m â†’ 1mm/texel
çº§è”2: 8m â†’ 2mm/texel
...
```

**é€‰æ‹©å»ºè®®**ï¼š
- **å®¤å†…/å°åœºæ™¯**: 1.0 - 2.0ç±³ï¼ˆé«˜ç²¾åº¦ï¼‰
- **å®¤å¤–/ä¸­åœºæ™¯**: 2.0 - 4.0ç±³ï¼ˆå¹³è¡¡ï¼‰
- **å¤§å‹å¼€æ”¾ä¸–ç•Œ**: 4.0 - 8.0ç±³ï¼ˆæ€§èƒ½ä¼˜å…ˆï¼‰

#### Filter Marginï¼ˆæ»¤æ³¢è¾¹ç¼˜ï¼‰

**ä½œç”¨**ï¼šä¸ºPCFæ»¤æ³¢é¢„ç•™çš„é¡µé¢è¾¹ç¼˜

```
filterMargin = 0: æ— PCFæ»¤æ³¢ï¼ˆç¡¬é˜´å½±ï¼‰
filterMargin = 1: 3Ã—3 PCFï¼ˆæ¨èï¼‰
filterMargin = 2: 5Ã—5 PCFï¼ˆæ›´è½¯ï¼Œæ›´å¤šé¡µé¢ï¼‰
filterMargin = 3: 7Ã—7 PCFï¼ˆæœ€è½¯ï¼Œæ€§èƒ½å¼€é”€å¤§ï¼‰
```

**å†…å­˜å½±å“**ï¼š
- margin=0: æ ‡è®°1ä¸ªé¡µé¢/åƒç´ 
- margin=1: æ ‡è®°9ä¸ªé¡µé¢/åƒç´ ï¼ˆ3Ã—3ï¼‰
- margin=2: æ ‡è®°25ä¸ªé¡µé¢/åƒç´ ï¼ˆ5Ã—5ï¼‰

**å»ºè®®**ï¼šä»1å¼€å§‹ï¼Œæ ¹æ®é˜´å½±è´¨é‡éœ€æ±‚è°ƒæ•´

#### Cascade Biasï¼ˆçº§è”åç§»ï¼‰

**ç”¨é€”**ï¼šå¾®è°ƒçº§è”é€‰æ‹©ï¼Œé¿å…è¾¹ç¼˜åˆ‡æ¢

```hlsl
level = âŒˆlogâ‚‚(distance / size)âŒ‰ + bias
```

- **bias = 0**: æ ‡å‡†é€‰æ‹©
- **bias = -1**: åå‘æ›´é«˜çº§è”ï¼ˆæ›´ç»†èŠ‚ï¼Œæ›´å¤šå†…å­˜ï¼‰
- **bias = +1**: åå‘æ›´ä½çº§è”ï¼ˆæ›´ç²—ç³™ï¼ŒèŠ‚çœå†…å­˜ï¼‰

**ä½¿ç”¨åœºæ™¯**ï¼š
- é¢‘ç¹çº§è”åˆ‡æ¢ â†’ bias = +0.5ï¼ˆå¹³æ»‘è¿‡æ¸¡ï¼‰
- è¿œå¤„ç»†èŠ‚ä¸è¶³ â†’ bias = -0.5ï¼ˆæå‡è¿œå¤„è´¨é‡ï¼‰

#### å¯å‘å¼é€‰æ‹©

| åœºæ™¯ç±»å‹ | æ¨èå¯å‘å¼ | åŸå›  |
|---------|-----------|------|
| FPSæ¸¸æˆ | è·ç¦»å¯å‘å¼ | æ—‹è½¬é¢‘ç¹ï¼Œéœ€è¦ç¨³å®šæ€§ |
| ç­–ç•¥æ¸¸æˆ | åƒç´ å®Œç¾ | å›ºå®šè§†è§’ï¼Œè¿½æ±‚æœ€ä¼˜ç»†èŠ‚ |
| ç¬¬ä¸‰äººç§° | è·ç¦»å¯å‘å¼ | ç›¸æœºè¿åŠ¨å¤æ‚ |
| å»ºç­‘æ¼«æ¸¸ | åƒç´ å®Œç¾ + biasè°ƒæ•´ | é™æ€åœºæ™¯ï¼Œé«˜è´¨é‡è¦æ±‚ |

### æ€§èƒ½åˆ†æå·¥å…·

#### è°ƒè¯•å¯è§†åŒ–

**å¯ç”¨æ–¹æ³•**ï¼šInspectorå‹¾é€‰"Debug Visualization"

**æ˜¾ç¤ºä¿¡æ¯**ï¼š
```
Virtual Shadow Maps Active
Physical Memory: 8192x4096
Cascades: 16
```

#### Frame Debuggerä½¿ç”¨

```
1. Window â†’ Analysis â†’ Frame Debugger
2. Enable â†’ Capture
3. æŸ¥æ‰¾ "Virtual Shadow Maps" CommandBuffer
4. å±•å¼€æŸ¥çœ‹æ¯ä¸ªcascadeçš„drawcall
```

**å…³æ³¨æŒ‡æ ‡**ï¼š
- DrawMeshæ•°é‡ï¼ˆå‰”é™¤æ•ˆç‡ï¼‰
- SetTexture/SetBufferè°ƒç”¨ï¼ˆçŠ¶æ€åˆ‡æ¢ï¼‰
- Compute Dispatchæ¬¡æ•°

#### æ€§èƒ½è®¡æ•°å™¨

åœ¨VirtualShadowMapManageræ·»åŠ ï¼š

```csharp
public struct VSMStats {
    public int allocatedPages;
    public int visiblePages;
    public int dirtyPages;
    public int drawCalls;
}

public VSMStats GetStats() {
    VSMStats stats;
    // ... ä»GPUè¯»å–ç»Ÿè®¡æ•°æ®
    return stats;
}
```

---

## æ€§èƒ½ä¼˜åŒ–

### å†…å­˜ä¼˜åŒ–

#### 1. çº§è”æ•°é‡è°ƒæ•´

```csharp
// é»˜è®¤ï¼š16çº§è”
public const int CASCADE_COUNT = 16;  // è¦†ç›–65km

// å®¤å†…åœºæ™¯ï¼š8çº§è”è¶³å¤Ÿ
public const int CASCADE_COUNT = 8;   // è¦†ç›–256m

// æé™æ€§èƒ½ï¼š4çº§è”
public const int CASCADE_COUNT = 4;   // è¦†ç›–16m
```

**å½±å“**ï¼š
- VPTå¤§å°ï¼š32Ã—32Ã—N
- çº§è”çŸ©é˜µï¼šNÃ—16 floats
- HPBå¤§å°ï¼šä¸Næˆæ­£æ¯”

#### 2. é¡µé¢åˆ†è¾¨ç‡è°ƒæ•´

```csharp
// é»˜è®¤ï¼š128Ã—128/é¡µ
public const int PAGE_SIZE = 128;

// é™ä½ç²¾åº¦æ¢æ€§èƒ½ï¼š64Ã—64/é¡µ
public const int PAGE_SIZE = 64;  // 4å€ç‰©ç†é¡µæ•°

// æå‡è´¨é‡ï¼š256Ã—256/é¡µ
public const int PAGE_SIZE = 256; // 1/4ç‰©ç†é¡µæ•°
```

**æƒè¡¡**ï¼š
- é¡µé¢è¶Šå¤§ â†’ ç¼“å­˜å‘½ä¸­ç‡â†“ï¼Œæµªè´¹â†‘
- é¡µé¢è¶Šå° â†’ é¡µè¡¨å¼€é”€â†‘ï¼Œç®¡ç†å¤æ‚åº¦â†‘

#### 3. ç‰©ç†å†…å­˜æ± å¤§å°

```csharp
// é»˜è®¤ï¼š8192Ã—4096 = 2048é¡µ
public const int PHYSICAL_MEMORY_WIDTH = 8192;
public const int PHYSICAL_MEMORY_HEIGHT = 4096;

// å†…å­˜å—é™ï¼š4096Ã—4096 = 1024é¡µ
public const int PHYSICAL_MEMORY_WIDTH = 4096;
public const int PHYSICAL_MEMORY_HEIGHT = 4096;

// é«˜ç«¯é…ç½®ï¼š16384Ã—4096 = 4096é¡µ
public const int PHYSICAL_MEMORY_WIDTH = 16384;
```

**å»ºè®®é…ç½®**ï¼š

| ç›®æ ‡å¹³å° | ç‰©ç†å†…å­˜ | é¡µæ•° | æ˜¾å­˜å ç”¨ |
|---------|---------|------|---------|
| ç§»åŠ¨ç«¯ | 2048Ã—2048 | 256 | ~16MB |
| ä¸»æœº/ä¸­ç«¯PC | 8192Ã—4096 | 2048 | ~128MB |
| é«˜ç«¯PC | 16384Ã—8192 | 8192 | ~512MB |

### æ¸²æŸ“ä¼˜åŒ–

#### 1. HPBå‰”é™¤é›†æˆ

**å®Œæ•´å®ç°æ­¥éª¤**ï¼š

```csharp
// a. å‡†å¤‡meshletæ•°æ®
struct Meshlet {
    float3 boundsMin;
    float3 boundsMax;
    uint meshletIndex;
}

ComputeBuffer meshletBuffer;

// b. æ‰§è¡ŒHPBå‰”é™¤
ComputeBuffer visibleMeshlets = new ComputeBuffer(maxMeshlets, 4, Append);
cullShader.SetBuffer(kernel, "_Meshlets", meshletBuffer);
cullShader.SetBuffer(kernel, "_VisibleMeshlets", visibleMeshlets);
cullShader.SetTexture(kernel, "_HPB", hpb.GetMipLevel(0));
cullShader.Dispatch(kernel, meshletCount/64, 1, 1);

// c. é—´æ¥ç»˜åˆ¶
ComputeBuffer indirectArgs;
ComputeBuffer.CopyCount(visibleMeshlets, indirectArgs, 0);
Graphics.DrawMeshInstancedIndirect(mesh, 0, material, bounds, indirectArgs);
```

**æ€§èƒ½æå‡**ï¼š
- é™æ€åœºæ™¯ï¼šå‡å°‘90%+ drawcall
- åŠ¨æ€åœºæ™¯ï¼šå‡å°‘50-70% drawcall

#### 2. æ‰¹é‡æ¸²æŸ“

**GPU Instancing**ï¼š

```csharp
// æ”¶é›†ç›¸åŒmeshçš„æ‰€æœ‰å®ä¾‹
List<Matrix4x4> matrices;
foreach (Renderer r in renderers) {
    if (r.sharedMesh == targetMesh) {
        matrices.Add(r.localToWorldMatrix);
    }
}

// å•æ¬¡drawcallæ¸²æŸ“æ‰€æœ‰å®ä¾‹
vsmCommandBuffer.DrawMeshInstanced(
    targetMesh,
    0,
    vsmDepthMaterial,
    0,
    matrices.ToArray()
);
```

#### 3. LODæ•´åˆ

```csharp
// æ ¹æ®çº§è”é€‰æ‹©LOD
int GetLODForCascade(int cascade) {
    if (cascade < 4) return 0;  // é«˜ç²¾åº¦çº§è”ç”¨LOD0
    if (cascade < 8) return 1;
    if (cascade < 12) return 2;
    return 3;  // è¿œè·ç¦»ç”¨æœ€ä½LOD
}

// æ¸²æŸ“æ—¶åº”ç”¨
foreach (Renderer r in renderers) {
    int lod = GetLODForCascade(currentCascade);
    Mesh mesh = r.GetComponent<LODGroup>().GetLODs()[lod].renderers[0].sharedMesh;
    vsmCommandBuffer.DrawMesh(mesh, ...);
}
```

### CPUä¼˜åŒ–

#### 1. å¯¹è±¡æ± 

```csharp
// é¿å…æ¯å¸§FindObjectsOfType
private Renderer[] cachedRenderers;
private bool renderersDirty = true;

void UpdateRendererCache() {
    if (renderersDirty) {
        cachedRenderers = FindObjectsOfType<Renderer>();
        renderersDirty = false;
    }
}

// ç‰©ä½“æ·»åŠ /åˆ é™¤æ—¶æ ‡è®°dirty
public void OnRendererAdded() { renderersDirty = true; }
```

#### 2. ç©ºé—´åˆ†åŒº

```csharp
// å…«å‰æ ‘åŠ é€Ÿçº§è”å‰”é™¤
Octree<Renderer> spatialIndex;

void DrawingPhase() {
    for (int cascade = 0; cascade < 16; cascade++) {
        Bounds cascadeBounds = GetCascadeBounds(cascade);
        List<Renderer> candidates = spatialIndex.Query(cascadeBounds);

        foreach (Renderer r in candidates) {
            // åªæ£€æŸ¥é™„è¿‘çš„ç‰©ä½“
        }
    }
}
```

#### 3. å¤šçº¿ç¨‹ä»»åŠ¡

```csharp
// åœ¨Job Systemä¸­æ‰§è¡Œè§†é”¥å‰”é™¤
struct FrustumCullJob : IJobParallelFor {
    [ReadOnly] public NativeArray<Bounds> bounds;
    [ReadOnly] public Matrix4x4 lightMatrix;
    [WriteOnly] public NativeArray<bool> results;

    public void Execute(int index) {
        results[index] = IsInFrustum(bounds[index], lightMatrix);
    }
}

// è°ƒåº¦
var job = new FrustumCullJob { ... };
var handle = job.Schedule(rendererCount, 64);
handle.Complete();
```

### GPUä¼˜åŒ–

#### 1. Async Compute

```csharp
// åœ¨å¼‚æ­¥é˜Ÿåˆ—æ‰§è¡ŒBookkeeping
CommandBuffer bookkeepingCmd = new CommandBuffer();
bookkeepingCmd.name = "VSM Bookkeeping";

// æ·»åŠ æ‰€æœ‰compute dispatches...

// å¼‚æ­¥æ‰§è¡Œ
Graphics.ExecuteCommandBufferAsync(
    bookkeepingCmd,
    ComputeQueueType.Background
);
```

#### 2. UAVéšœç¢ä¼˜åŒ–

```hlsl
// âŒ æ¯æ¬¡å†™å…¥åbarrier
for (int i = 0; i < count; i++) {
    VPT[i] = ...;
    AllMemoryBarrierWithGroupSync();  // æ˜‚è´µï¼
}

// âœ… æ‰¹é‡å†™å…¥åå•æ¬¡barrier
for (int i = 0; i < count; i++) {
    VPT[i] = ...;
}
AllMemoryBarrierWithGroupSync();  // ä»…ä¸€æ¬¡
```

#### 3. æ³¢å‰å ç”¨ç‡

```hlsl
// è°ƒæ•´çº¿ç¨‹ç»„å¤§å°åŒ¹é…GPUæ³¢å‰
// NVIDIA (32-wide): [numthreads(32,1,1)] æˆ– [numthreads(8,4,1)]
// AMD (64-wide):    [numthreads(64,1,1)] æˆ– [numthreads(8,8,1)]

// é¿å…
[numthreads(33,1,1)]  // æµªè´¹31ä¸ªçº¿ç¨‹
```

---

## é—®é¢˜æ’æŸ¥

### å¸¸è§é—®é¢˜

#### é—®é¢˜1ï¼šé˜´å½±å®Œå…¨ä¸æ˜¾ç¤º

**å¯èƒ½åŸå› **ï¼š
1. âœ… DrawingPhaseæœªæ‰§è¡Œ
2. âœ… ç‰©ç†å†…å­˜æœªæ­£ç¡®ç»‘å®š
3. âœ… æè´¨æœªåŒ…å«VSMé‡‡æ ·ä»£ç 
4. âœ… å…‰æºæ–¹å‘é”™è¯¯

**æ’æŸ¥æ­¥éª¤**ï¼š
```csharp
// 1. æ·»åŠ æ—¥å¿—
void DrawingPhase() {
    Debug.Log($"Drawing {cascadeCount} cascades");
    if (vsmDepthMaterial == null) {
        Debug.LogError("VSM Depth Material is null!");
        return;
    }
    // ...
}

// 2. æ£€æŸ¥ç‰©ç†å†…å­˜
void OnGUI() {
    if (GUILayout.Button("Check Physical Memory")) {
        RenderTexture.active = physicalMemory.Texture;
        Texture2D readback = new Texture2D(256, 256);
        readback.ReadPixels(new Rect(0,0,256,256), 0, 0);
        readback.Apply();

        // ä¿å­˜æŸ¥çœ‹
        File.WriteAllBytes("vsm_debug.png", readback.EncodeToPNG());
    }
}

// 3. éªŒè¯é‡‡æ ·
// åœ¨æè´¨shaderä¸­ä¸´æ—¶è¿”å›å›ºå®šé¢œè‰²
float shadow = SampleVSM(worldPos);
return float4(shadow, 0, 0, 1); // åº”æ˜¾ç¤ºçº¢è‰²æ¸å˜
```

#### é—®é¢˜2ï¼šé˜´å½±é—ªçƒ/æŠ–åŠ¨

**åŸå› åˆ†æ**ï¼š
- **ç›¸æœºç§»åŠ¨**ï¼šé¡µé¢ç¼“å­˜å¤±æ•ˆé¢‘ç¹
- **å…‰æºæŠ–åŠ¨**ï¼šæœªæ­£ç¡®å®ç°å¹³é¢çº¦æŸ
- **çº§è”åˆ‡æ¢**ï¼šå¯å‘å¼å¯¼è‡´çº§è”è·³å˜

**è§£å†³æ–¹æ¡ˆ**ï¼š

```csharp
// a. å¢åŠ ç¼“å­˜ç¨³å®šæ€§
float pageWorldSize = cascadeSize / PAGE_TABLE_RESOLUTION;
// åŠ å¤§å¯¹é½ç²’åº¦
pageWorldSize *= 2.0f;

// b. éªŒè¯å…‰æºçº¦æŸ
Debug.DrawRay(lightPos, lightDir, Color.yellow);
Debug.DrawRay(lightPos, right, Color.red);
Debug.DrawRay(lightPos, up, Color.green);
// ç§»åŠ¨å…‰æºæ—¶ï¼Œé»„çº¿åº”ä¿æŒå›ºå®šæ–¹å‘

// c. åˆ‡æ¢å¯å‘å¼
usePixelPerfectHeuristic = false; // è·ç¦»å¯å‘å¼æ›´ç¨³å®š

// d. æ·»åŠ çº§è”bias
cascadeBias = 0.5f; // å‡å°‘è¾¹ç•Œåˆ‡æ¢
```

#### é—®é¢˜3ï¼šé˜´å½±æœ‰é”¯é½¿

**åŸå› **ï¼š
- filterMarginè®¾ç½®ä¸º0ï¼ˆæ— PCFï¼‰
- çº§è”é€‰æ‹©ä¸å½“
- ç‰©ç†å†…å­˜ä¸è¶³

**ä¼˜åŒ–æ–¹æ¡ˆ**ï¼š

```csharp
// 1. å¯ç”¨PCF
filterMargin = 1;  // 3Ã—3 PCF

// 2. åœ¨shaderä¸­å¢å¤§æ»¤æ³¢æ ¸
float shadow = SampleVSM_PCF(worldPos, 3.0); // filterSize=3

// 3. æå‡é¦–çº§è”åˆ†è¾¨ç‡
firstCascadeSize = 1.0f; // ä»2.0é™åˆ°1.0

// 4. æ£€æŸ¥çº§è”é€‰æ‹©
void OnDrawGizmos() {
    // å¯è§†åŒ–çº§è”
    for (int i = 0; i < 16; i++) {
        Gizmos.color = Color.HSVToRGB(i/16f, 1, 1);
        DrawCascadeBounds(i);
    }
}
```

#### é—®é¢˜4ï¼šæ€§èƒ½è¿‡ä½

**è¯Šæ–­**ï¼š

```csharp
// æ·»åŠ æ€§èƒ½è®¡æ—¶
Profiler.BeginSample("VSM Bookkeeping");
BookkeepingPhase();
Profiler.EndSample();

Profiler.BeginSample("VSM Drawing");
DrawingPhase();
Profiler.EndSample();
```

**å¸¸è§ç“¶é¢ˆ**ï¼š

| ç“¶é¢ˆ | è¡¨ç° | è§£å†³æ–¹æ¡ˆ |
|-----|------|---------|
| GPU Compute | Bookkeepingè€—æ—¶>5ms | å‡å°‘çº§è”æ•°é‡ |
| DrawCall | Drawingè€—æ—¶>10ms | å¯ç”¨HPBå‰”é™¤ã€GPU Instancing |
| å†…å­˜å¸¦å®½ | æ•´ä½“å¡é¡¿ | é™ä½ç‰©ç†å†…å­˜åˆ†è¾¨ç‡ |
| CPUå‰”é™¤ | CPUå ç”¨é«˜ | ç©ºé—´åˆ†åŒºã€Job System |

#### é—®é¢˜5ï¼šè¿œå¤„é˜´å½±æ¶ˆå¤±

**åŸå› **ï¼šçº§è”è¦†ç›–èŒƒå›´ä¸è¶³

**è®¡ç®—è¦†ç›–èŒƒå›´**ï¼š
```
çº§è”Nçš„æœ€è¿œè·ç¦» = firstCascadeSize Ã— 2^N

ä¾‹å¦‚ï¼š
firstCascadeSize = 2m
çº§è”15: 2 Ã— 2^15 = 65,536m = 65.5km
```

**è§£å†³**ï¼š
```csharp
// æ–¹æ¡ˆ1: å¢åŠ çº§è”æ•°ï¼ˆæ…ç”¨ï¼Œæ€§èƒ½å¼€é”€å¤§ï¼‰
CASCADE_COUNT = 20; // è¦†ç›–1,048km

// æ–¹æ¡ˆ2: å¢å¤§é¦–çº§è”å°ºå¯¸
firstCascadeSize = 4.0f; // è¦†ç›–131km

// æ–¹æ¡ˆ3: æ··åˆæ–¹æ¡ˆ
// è¿‘å¤„ç²¾ç»†çº§è” + è¿œå¤„å•ä¸ªä½ç²¾åº¦shadow map
```

### è°ƒè¯•å·¥å…·

#### 1. å¯è§†åŒ–çº§è”åˆ†å¸ƒ

```csharp
void OnDrawGizmos() {
    if (!Application.isPlaying) return;

    for (int i = 0; i < CASCADE_COUNT; i++) {
        Gizmos.color = new Color(i/16f, 1-i/16f, 0.5f, 0.3f);

        Matrix4x4 mat = cascadeLightMatrices[i];
        Vector3 center = mat.inverse.MultiplyPoint(Vector3.zero);
        float size = firstCascadeSize * Mathf.Pow(2, i);

        Gizmos.DrawWireCube(center, Vector3.one * size);

        // æ˜¾ç¤ºçº§è”ç¼–å·
        #if UNITY_EDITOR
        UnityEditor.Handles.Label(center, $"Cascade {i}");
        #endif
    }
}
```

#### 2. é¡µè¡¨æŸ¥çœ‹å™¨

```csharp
public Texture2D GeneratePageTableVisualization(int cascade) {
    RenderTexture.active = pageTable.VirtualPageTableTexture;

    Texture2D tex = new Texture2D(32, 32);
    Color[] pixels = new Color[32 * 32];

    for (int y = 0; y < 32; y++) {
        for (int x = 0; x < 32; x++) {
            uint entry = ReadPageEntry(x, y, cascade);

            if (GetIsAllocated(entry) && GetIsVisible(entry) && GetIsDirty(entry))
                pixels[y*32+x] = Color.red;      // çº¢ï¼šå¾…æ¸²æŸ“
            else if (GetIsAllocated(entry) && GetIsVisible(entry))
                pixels[y*32+x] = Color.green;    // ç»¿ï¼šå·²æ¸²æŸ“
            else if (GetIsAllocated(entry))
                pixels[y*32+x] = Color.blue;     // è“ï¼šç¼“å­˜
            else
                pixels[y*32+x] = Color.black;    // é»‘ï¼šæœªåˆ†é…
        }
    }

    tex.SetPixels(pixels);
    tex.Apply();
    return tex;
}
```

#### 3. å®æ—¶ç»Ÿè®¡é¢æ¿

```csharp
void OnGUI() {
    if (!debugVisualization) return;

    GUILayout.BeginArea(new Rect(10, 10, 300, 400));
    GUILayout.Label("=== VSM Statistics ===");

    // è®¡ç®—ç»Ÿè®¡æ•°æ®
    int totalPages = 32 * 32 * CASCADE_COUNT;
    int allocatedPages = CountAllocatedPages();
    int dirtyPages = CountDirtyPages();

    GUILayout.Label($"Total Virtual Pages: {totalPages}");
    GUILayout.Label($"Allocated Pages: {allocatedPages} ({100f*allocatedPages/totalPages:F1}%)");
    GUILayout.Label($"Dirty Pages: {dirtyPages}");
    GUILayout.Label($"Physical Pages: {MAX_PHYSICAL_PAGES}");
    GUILayout.Label($"Memory Usage: {CalculateMemoryMB():F1} MB");

    GUILayout.Space(10);
    GUILayout.Label("=== Performance ===");
    GUILayout.Label($"Bookkeeping: {bookkeepingTime:F2} ms");
    GUILayout.Label($"Drawing: {drawingTime:F2} ms");
    GUILayout.Label($"DrawCalls: {drawCallCount}");

    GUILayout.EndArea();
}
```

---

## é™„å½•

### å®Œæ•´ä»£ç ä½ç½®ç´¢å¼•

#### C# è„šæœ¬
- **VirtualShadowMapManager.cs** - ä¸»ç®¡ç†å™¨
  - `Start()` - åˆå§‹åŒ– (58-61)
  - `UpdateCascadeMatrices()` - çº§è”çŸ©é˜µ (87-150)
  - `BookkeepingPhase()` - å‡†å¤‡é˜¶æ®µ (178-318)
  - `DrawingPhase()` - ç»˜åˆ¶é˜¶æ®µ (320-384) â­
  - `IsInCascadeFrustum()` - è§†é”¥å‰”é™¤ (386-421)

- **VSMPageTable.cs** - é¡µè¡¨ç®¡ç† (10-157)
- **VSMPhysicalMemory.cs** - ç‰©ç†å†…å­˜ç®¡ç†
- **VSMHierarchicalPageBuffer.cs** - HPBç®¡ç† (52-80)
- **VSMConstants.cs** - å¸¸é‡å®šä¹‰

#### Compute Shaders
- **VSMFreeInvalidatedPages.compute** - é‡Šæ”¾é¡µé¢
- **VSMMarkVisiblePages.compute** - æ ‡è®°å¯è§é¡µ (40-104)
- **VSMAllocatePages.compute** - åˆ†é…é¡µé¢ (1-172)
- **VSMClearPages.compute** - æ¸…é™¤é¡µé¢
- **VSMBuildHPB.compute** - æ„å»ºHPB (1-44)
- **VSMCullAndDraw.compute** - HPBå‰”é™¤ç¤ºä¾‹ (1-49)

#### æ¸²æŸ“ Shaders
- **VSMDepthRender.shader** - æ·±åº¦æ¸²æŸ“ (67-115)
- **VSMSampling.hlsl** - é‡‡æ ·å‡½æ•° (18-127)
- **VSMCommon.hlsl** - å…¬å…±å‡½æ•°åº“ (1-172)

### å‚æ•°é€ŸæŸ¥è¡¨

| å‚æ•° | é»˜è®¤å€¼ | èŒƒå›´ | è¯´æ˜ |
|-----|-------|------|------|
| PAGE_TABLE_RESOLUTION | 32 | 16-64 | æ¯çº§è”é¡µè¡¨åˆ†è¾¨ç‡ |
| PAGE_SIZE | 128 | 64-256 | æ¯é¡µåƒç´ æ•° |
| CASCADE_COUNT | 16 | 4-20 | çº§è”æ•°é‡ |
| PHYSICAL_MEMORY_WIDTH | 8192 | 2048-16384 | ç‰©ç†å†…å­˜å®½åº¦ |
| PHYSICAL_MEMORY_HEIGHT | 4096 | 2048-8192 | ç‰©ç†å†…å­˜é«˜åº¦ |
| firstCascadeSize | 2.0 | 0.5-8.0 | é¦–çº§è”è¾¹é•¿(ç±³) |
| filterMargin | 1 | 0-3 | PCFæ»¤æ³¢è¾¹ç¼˜ |
| cascadeBias | 0 | -2 ~ +2 | çº§è”é€‰æ‹©åç§» |

### å…¬å¼æ±‡æ€»

**çº§è”é€‰æ‹©**ï¼š
```
è·ç¦»å¯å‘å¼: level = âŒˆlogâ‚‚(d / s_câ‚€)âŒ‰
åƒç´ å®Œç¾:   level = âŒˆlogâ‚‚(T_w / T_câ‚€)âŒ‰
```

**åæ ‡è½¬æ¢**ï¼š
```
è™šæ‹ŸUV â†’ é¡µåæ ‡: pageCoords = floor(virtualUV Ã— 32)
ç¯å½¢æ˜ å°„:        wrappedCoords = (pageCoords + offset) % 32
ç‰©ç†åæ ‡:        physicalTexel = physicalPage Ã— 128 + inPageOffset
```

**è¦†ç›–èŒƒå›´**ï¼š
```
çº§è”Næœ€è¿œè·ç¦» = firstCascadeSize Ã— 2^N
è™šæ‹Ÿåˆ†è¾¨ç‡ = PAGE_TABLE_RESOLUTION Ã— PAGE_SIZE = 32 Ã— 128 = 4096
ç‰©ç†é¡µæ•° = (WIDTH / PAGE_SIZE) Ã— (HEIGHT / PAGE_SIZE) = 64 Ã— 32 = 2048
```

### è®ºæ–‡å¯¹ç…§

| è®ºæ–‡ç« èŠ‚ | å®ç°ä½ç½® | é¡µç  |
|---------|---------|------|
| 12.1 Introduction | README.md | - |
| 12.2 Implementation | VirtualShadowMapManager.cs | - |
| 12.2.1 Bookkeeping | è¡Œ178-318 | - |
| - Listing 12.1 æ»‘åŠ¨çª—å£ | VSMCommon.hlsl:55-75 | - |
| - Listing 12.2 é‡Šæ”¾é¡µé¢ | VSMFreeInvalidatedPages.compute | - |
| 12.2.2 Drawing Phase | è¡Œ320-384 | - |
| - Listing 12.3 Fragment Shader | VSMDepthRender.shader:67-115 | - |
| 12.2.3 Sampling Phase | VSMSampling.hlsl | - |

---

## æ€»ç»“

è™šæ‹Ÿé˜´å½±è´´å›¾æ˜¯ä¸€é¡¹å¤æ‚ä½†å¼ºå¤§çš„æŠ€æœ¯ï¼Œé€šè¿‡è™šæ‹Ÿå†…å­˜æŠ½è±¡å®ç°äº†ï¼š

1. **æè‡´çš„åˆ†è¾¨ç‡** - 4096Ã—4096Ã—16çº§è”è™šæ‹Ÿç©ºé—´
2. **æä½çš„å¼€é”€** - ç¨€ç–åˆ†é…ï¼Œåªå ç”¨å¯è§é¡µé¢
3. **ç»Ÿä¸€çš„ç®¡çº¿** - å•ä¸€æ–¹æ¡ˆæ›¿ä»£å¤šç§é˜´å½±æŠ€æœ¯
4. **æ™ºèƒ½çš„ç¼“å­˜** - é¡µé¢é‡ç”¨ï¼Œå‡å°‘é‡å¤æ¸²æŸ“

### ä¸‰å¤§æ ¸å¿ƒæœºåˆ¶
- **è™šæ‹Ÿé¡µè¡¨** - çµæ´»çš„è™šæ‹Ÿâ†’ç‰©ç†æ˜ å°„
- **æ»‘åŠ¨çª—å£** - é«˜æ•ˆçš„ç¼“å­˜å¤ç”¨
- **HPBå‰”é™¤** - ç²¾å‡†çš„å‡ ä½•è£å‰ª

### å…³é”®ä¼˜åŠ¿
âœ… æ”¯æŒNaniteçº§åˆ«çš„é«˜å¤šè¾¹å½¢åœºæ™¯
âœ… è‡ªé€‚åº”ç»†èŠ‚åˆ†é…ï¼Œæ— éœ€æ‰‹åŠ¨è°ƒä¼˜
âœ… æ—‹è½¬ä¸å˜çš„çº§è”é€‰æ‹©
âœ… åŸç”Ÿæ”¯æŒè½¯é˜´å½±ï¼ˆPCF/PCSSï¼‰

### å®ç°è¦ç‚¹
1. ä¸¥æ ¼éµå¾ªè®ºæ–‡çš„ä¸¤é˜¶æ®µåˆ†é…ç­–ç•¥
2. æ­£ç¡®å®ç°å…‰æºä½ç½®å¹³é¢çº¦æŸ
3. ä½¿ç”¨ç¡¬ä»¶æ’å€¼æ·±åº¦å€¼ï¼ˆgl_FragCoord.zï¼‰
4. HPBå‰”é™¤æ˜¯æ€§èƒ½å…³é”®

**æœ¬æ–‡æ¡£è¦†ç›–äº†ä»åŸç†åˆ°å®ç°çš„å®Œæ•´çŸ¥è¯†ä½“ç³»ï¼Œå¯ä½œä¸ºVSMæŠ€æœ¯çš„æƒå¨å‚è€ƒã€‚**

---

**æ–‡æ¡£ç‰ˆæœ¬**: 1.0
**æœ€åæ›´æ–°**: 2025-10-03
**ä½œè€…**: VSM Implementation Team
**åŸºäºè®ºæ–‡**: GPU Zen 3, Chapter 12 - Virtual Shadow Maps
