# 虚拟阴影贴图（Virtual Shadow Maps）完整实现文档

## 📋 目录

1. [技术概述](#技术概述)
2. [核心概念](#核心概念)
3. [系统架构](#系统架构)
4. [三大执行阶段](#三大执行阶段)
5. [关键算法详解](#关键算法详解)
6. [数据结构设计](#数据结构设计)
7. [Shader实现细节](#shader实现细节)
8. [使用指南](#使用指南)
9. [性能优化](#性能优化)
10. [问题排查](#问题排查)

---

## 技术概述

### 什么是虚拟阴影贴图（VSM）？

虚拟阴影贴图是一种基于**虚拟纹理（Virtual Texturing）**技术的高级阴影映射方法，首次应用于Unreal Engine 5。它通过将虚拟地址空间与物理内存分离，实现了：

- ✅ **超高分辨率阴影** - 支持4096×4096×16级联的虚拟分辨率
- ✅ **极低内存占用** - 只分配可见页面，典型场景节省90%+内存
- ✅ **统一阴影管线** - 替代多种阴影技术的组合方案
- ✅ **自动细节分配** - 根据距离和视角自动调整阴影精度

### 核心优势

| 传统阴影贴图 | 虚拟阴影贴图 |
|------------|------------|
| 固定分辨率，浪费内存 | 稀疏分配，按需加载 |
| 需要多种技术组合（CSM、接触阴影等） | 单一统一方案 |
| 透视失真严重 | 自适应细节层级 |
| 难以支持高多边形场景 | 与Nanite等技术完美配合 |

---

## 核心概念

### 1. 虚拟内存系统

```
虚拟地址空间（4096×4096×16）
        ↓ 页表映射
物理内存（8192×4096，仅2048页）
```

#### 关键组件：

**虚拟页表（VPT）**
- 类型：3D纹理数组，每个级联32×32页
- 存储：每个页面的状态标志和物理坐标
- 功能：虚拟页→物理页的映射查找

**物理页表（PPT）**
- 类型：ComputeBuffer
- 存储：物理页→虚拟页的反向映射
- 功能：页面重用时快速释放旧映射

**物理内存池**
- 类型：RenderTexture（R32_Float）
- 分辨率：8192×4096像素
- 页面布局：64列×32行 = 2048个物理页
- 每页大小：128×128像素

### 2. 页面生命周期

```
[未分配] → [分配+可见+脏] → [分配+可见+干净] → [分配+不可见] → [未分配]
    ↑            ↓                  ↓                  ↓              ↑
    |         首次分配           渲染完成          离开视野        被复用
    └──────────────────────────────────────────────────────────────┘
```

#### 页面状态标志：

```hlsl
#define VSM_ALLOCATED_BIT 0x1u  // 已分配物理内存
#define VSM_VISIBLE_BIT 0x2u    // 当前帧可见
#define VSM_DIRTY_BIT 0x4u      // 需要重新渲染
```

### 3. 级联系统

16个同心级联，每个级联尺寸是上一级的2倍：

```
级联0: 2×2米（最高精度，靠近相机）
级联1: 4×4米
级联2: 8×8米
...
级联15: 65536×65536米（覆盖65km）
```

每个级联都有独立的虚拟页表（32×32），共享同一物理内存池。

### 4. 页面缓存与滑动窗口

为了支持缓存，级联视锥需要对齐到页面网格：

```cpp
// 页面网格对齐
float pageWorldSize = cascadeSize / PAGE_TABLE_RESOLUTION;
Vector3 snappedPos = floor(cameraPos / pageWorldSize) * pageWorldSize;
```

**滑动窗口（Wraparound Addressing）**：
当相机移动时，虚拟页表使用环形缓冲区，新进入的页面复用退出页面的位置：

```hlsl
int2 wrappedCoords = (pageCoords + cascadeOffset) % PAGE_TABLE_RESOLUTION;
```

---

## 系统架构

### 整体流程图

```
每帧执行：
┌─────────────────────────────────────────┐
│         OnPreRender()                   │
│  ┌─────────────────────────────────┐   │
│  │   ExecuteVSMPipeline()          │   │
│  │  ┌───────────────────────────┐  │   │
│  │  │ 1. Bookkeeping 阶段        │  │   │
│  │  │   - 释放失效页面           │  │   │
│  │  │   - 标记可见页面           │  │   │
│  │  │   - 填充分配器缓冲区       │  │   │
│  │  │   - 分配物理页面           │  │   │
│  │  │   - 清除脏页面             │  │   │
│  │  │   - 构建HPB               │  │   │
│  │  └───────────────────────────┘  │   │
│  │  ┌───────────────────────────┐  │   │
│  │  │ 2. Drawing 阶段 ⭐         │  │   │
│  │  │   - 遍历16个级联           │  │   │
│  │  │   - 视锥剔除              │  │   │
│  │  │   - HPB剔除（可选）        │  │   │
│  │  │   - 渲染几何到物理内存     │  │   │
│  │  └───────────────────────────┘  │   │
│  │  ┌───────────────────────────┐  │   │
│  │  │ 3. 绑定数据供采样          │  │   │
│  │  │   - 设置全局Shader参数     │  │   │
│  │  └───────────────────────────┘  │   │
│  └─────────────────────────────────┘   │
└─────────────────────────────────────────┘
                 ↓
         渲染主场景时采样VSM
```

### 核心类设计

```
VirtualShadowMapManager (主管理器)
├── VSMPageTable (虚拟页表)
│   ├── virtualPageTable: RenderTexture
│   ├── allocationRequests: ComputeBuffer
│   ├── freePhysicalPages: ComputeBuffer
│   └── usedPhysicalPages: ComputeBuffer
│
├── VSMPhysicalPageTable (物理页表)
│   └── physicalPageTable: ComputeBuffer
│
├── VSMPhysicalMemory (物理内存)
│   └── texture: RenderTexture (8192×4096)
│
└── VSMHierarchicalPageBuffer (层级页面缓冲)
    └── hpbMipChain: RenderTexture[] (mip链)
```

---

## 三大执行阶段

### 阶段一：Bookkeeping（准备阶段）

**位置**：`VirtualShadowMapManager.cs:178-318`

这个阶段准备本帧需要渲染的页面，包含5个步骤：

#### Step 1: 释放失效页面（Free Invalidated Pages）

**代码位置**：行 180-193
**Compute Shader**：`VSMFreeInvalidatedPages.compute`

**目的**：清除因以下原因失效的缓存页面：
- 相机移动导致级联视锥平移（滑动窗口机制）
- 动态物体运动导致阴影失效

**实现细节**：
```cpp
// CPU端计算级联移动量
Vector2Int cascadeShift = newOffset - oldOffset;

// GPU端检查是否需要释放
bool shouldClearWrap =
    (cascadeShift.x > 0 && pageCoords.x < cascadeShift.x) ||
    (cascadeShift.x < 0 && pageCoords.x > TABLE_RES + cascadeShift.x - 1) ||
    // y方向同理...

bool shouldClearDynamic = extractBitFromMask(pageCoords, dynamicMask);

if (shouldClearWrap || shouldClearDynamic) {
    VPT[wrappedCoords] = 0; // 重置为未分配状态
}
```

#### Step 2: 标记可见页面（Mark Visible Pages）

**代码位置**：行 195-227
**Compute Shader**：`VSMMarkVisiblePages.compute`

**目的**：分析相机深度缓冲，确定哪些VSM页面在当前视角可见

**实现流程**：
```hlsl
// 1. 读取深度缓冲重建世界坐标
float depth = _CameraDepthTexture[screenUV];
float3 worldPos = ReconstructWorldPosition(screenUV, depth);

// 2. 选择级联（两种启发式）
int cascadeLevel;
if (usePixelPerfectHeuristic) {
    // 启发式1: 像素完美（1:1映射）
    level = ⌈log₂(T_screen / T_cascade0)⌉
} else {
    // 启发式2: 基于距离（旋转不变）
    level = ⌈log₂(distance / cascadeSize0)⌉
}

// 3. 投影到光空间，计算虚拟页坐标
float2 lightUV = WorldToLightUV(worldPos, cascadeMatrix);
int2 pageCoords = floor(lightUV * PAGE_TABLE_RES);

// 4. 为PCF滤波标记周围页面
for (dy = -filterMargin; dy <= filterMargin; dy++) {
    for (dx = -filterMargin; dx <= filterMargin; dx++) {
        int2 neighborPage = pageCoords + int2(dx, dy);
        uint pageEntry = VPT[neighborPage];

        if (!IsAllocated(pageEntry)) {
            // 请求分配
            _AllocationRequests.Append(neighborPage);
        } else if (!IsVisible(pageEntry)) {
            // 标记为可见
            InterlockedOr(VPT[neighborPage], VISIBLE_BIT);
        }
    }
}
```

**两种级联选择启发式**：

| 启发式 | 公式 | 优点 | 缺点 |
|-------|------|------|------|
| 像素完美 | level = ⌈log₂(T_w / T_c₀)⌉ | 理论最优，1:1映射 | 可能选到视锥外，旋转时抖动 |
| 基于距离 | level = ⌈log₂(d / s_c₀)⌉ | 旋转不变，稳定 | 非严格1:1映射 |

T_w = 屏幕像素世界尺寸, T_c₀ = 级联0纹素世界尺寸
d = 距相机距离, s_c₀ = 级联0边长

#### Step 3: 填充分配器缓冲区（Fill Allocator Buffers）

**代码位置**：行 229-241
**Compute Shader**：`VSMAllocatePages.compute` (FillAllocatorBuffers kernel)

**目的**：将所有物理页面分类到两个缓冲区：

```cpp
for (每个物理页面) {
    if (!已分配) {
        freePages.Append(页面); // 第一优先级：空闲页
    } else {
        if (!对应虚拟页可见) {
            usedButInvisiblePages.Append(页面); // 第二优先级：可复用页
        }
        // 可见页不加入任何缓冲区（保持不动）
    }
}
```

**论文原文**：
> "The first buffer contains the coordinates of all pages that have not yet been allocated to a VSM page. The second buffer holds the coordinates of all physical pages that have been allocated but are backing virtual pages that were not marked as visible in this frame."

#### Step 4: 分配页面（Allocate Pages）

**代码位置**：行 243-280
**Compute Shader**：`VSMAllocatePages.compute` (AllocatePages kernel)

**目的**：使用**两阶段分配策略**为请求分配的虚拟页面分配物理内存

**两阶段分配算法**：

```hlsl
// 阶段1: 优先使用完全空闲的物理页
uint freeIndex;
InterlockedAdd(_AllocationCounter[0], 1, freeIndex);

if (freeIndex < freePageCount) {
    physicalPage = _FreePages[freeIndex];
    // 直接使用，无需释放
} else {
    // 阶段2: 空闲页不足，复用已分配但不可见的页
    uint usedIndex;
    InterlockedAdd(_AllocationCounter[1], 1, usedIndex);

    if (usedIndex < usedPageCount) {
        physicalPage = _UsedPages[usedIndex];

        // 关键：先释放旧的虚拟页映射
        int3 oldVirtualPage = PPT[physicalPage].xyz;
        VPT[oldVirtualPage] = 0; // 重置旧虚拟页
    }
}

// 建立新映射
VPT[virtualPage] = PackEntry(true, true, true, physicalPage);
PPT[physicalPage] = (virtualPage, 1);
```

**论文强调**：
> "The allocator attempts to use physical pages from the first buffer, holding unallocated pages. Only when there are insufficient free pages are the pages in the second buffer used. [...] the page must first be freed before it is reused."

#### Step 5: 清除脏页面（Clear Dirty Pages）

**代码位置**：行 282-305
**Compute Shader**：`VSMClearPages.compute`

**目的**：将新分配的物理页面清零（深度设为1.0 = 无穷远）

```hlsl
// 遍历所有分配请求
for (每个分配请求) {
    uint pageEntry = VPT[virtualPage];
    if (!IsAllocated(pageEntry)) continue;

    int2 physicalPage = UnpackPhysicalCoords(pageEntry);

    // 清除整个物理页（128×128）
    for (y = 0; y < PAGE_SIZE; y++) {
        for (x = 0; x < PAGE_SIZE; x++) {
            int2 texel = physicalPage * PAGE_SIZE + int2(x, y);
            _PhysicalMemory[texel] = 1.0; // 远平面
        }
    }
}
```

使用间接调度（Indirect Dispatch）提高效率。

#### Step 6: 构建层级页面缓冲（Build HPB）

**代码位置**：行 310
**类方法**：`VSMHierarchicalPageBuffer.cs:52-80`
**Compute Shader**：`VSMBuildHPB.compute`

**目的**：构建用于几何剔除的加速结构（类似Hi-Z，但存储dirty标志）

**构建流程**：

```hlsl
// Level 0: 从VPT提取dirty标志
if (mipLevel == 0) {
    uint pageEntry = VPT[pageCoords];
    dirtyValue = GetIsDirty(pageEntry) ? 1.0 : 0.0;
}
// Level N: 2×2 max reduction
else {
    int2 srcCoord = dstCoord * 2;
    float v00 = HPB[mipLevel-1][srcCoord + (0,0)];
    float v01 = HPB[mipLevel-1][srcCoord + (1,0)];
    float v10 = HPB[mipLevel-1][srcCoord + (0,1)];
    float v11 = HPB[mipLevel-1][srcCoord + (1,1)];
    dirtyValue = max(max(v00,v01), max(v10,v11));
}
HPB[mipLevel][dstCoord] = dirtyValue;
```

**Mip链结构**：
```
Level 0: 32×32 (原始分辨率)
Level 1: 16×16
Level 2: 8×8
Level 3: 4×4
Level 4: 2×2
Level 5: 1×1
```

---

### 阶段二：Drawing（绘制/烘焙阶段）⭐

**位置**：`VirtualShadowMapManager.cs:320-384`

**这是核心的阴影深度烘焙代码！**

#### 主流程实现

```csharp
void DrawingPhase()
{
    // 1. 初始化CommandBuffer
    vsmCommandBuffer.Clear();

    // 2. 设置全局Shader参数
    vsmCommandBuffer.SetGlobalTexture("_VirtualPageTable", pageTable.VPT);
    vsmCommandBuffer.SetGlobalTexture("_PhysicalMemory", physicalMemory.Texture);
    vsmCommandBuffer.SetGlobalBuffer("_CascadeLightMatrices", cascadeMatrices);
    vsmCommandBuffer.SetGlobalBuffer("_CascadeOffsets", cascadeOffsets);

    // 3. 获取所有阴影投射物
    Renderer[] renderers = FindObjectsOfType<Renderer>();

    // 4. 遍历16个级联
    for (int cascade = 0; cascade < 16; cascade++)
    {
        vsmCommandBuffer.SetGlobalInt("_CurrentCascade", cascade);

        foreach (Renderer renderer in renderers)
        {
            // a. 层级过滤
            if (!IsShadowCaster(renderer)) continue;

            // b. 视锥剔除
            if (!IsInCascadeFrustum(renderer.bounds, cascade))
                continue;

            // c. HPB剔除（可选，高级优化）
            if (useHPBCulling && !PassHPBCull(renderer, cascade))
                continue;

            // d. 记录绘制命令
            vsmCommandBuffer.DrawMesh(
                mesh,
                worldMatrix,
                vsmDepthMaterial,
                submeshIndex: 0,
                shaderPass: 0
            );
        }
    }

    // 5. 执行所有绘制命令
    Graphics.ExecuteCommandBuffer(vsmCommandBuffer);
}
```

#### 视锥剔除实现

**位置**：`VirtualShadowMapManager.cs:386-421`

```csharp
bool IsInCascadeFrustum(Bounds bounds, int cascadeIndex)
{
    Matrix4x4 lightMatrix = cascadeLightMatrices[cascadeIndex];

    // 检查AABB的8个顶点
    for (int i = 0; i < 8; i++)
    {
        Vector3 corner = bounds.center + ExtractCorner(bounds.extents, i);
        Vector4 lightSpace = lightMatrix * new Vector4(corner, 1);
        Vector3 ndc = lightSpace.xyz / lightSpace.w;

        // 如果任一顶点在NDC立方体内 [-1,1]³
        if (IsInNDCCube(ndc))
            return true;
    }
    return false;
}
```

#### VSM深度Shader

**位置**：`Assets/Shaders/VSM/VSMDepthRender.shader:67-115`

**Fragment Shader核心代码**：

```hlsl
void frag(v2f i, out float depth : SV_Depth)
{
    // 1. 计算虚拟纹理坐标（论文Listing 12.3）
    int2 virtualTexel = int2(i.pos.xy); // gl_FragCoord.xy
    float2 virtualUV = virtualTexel / float(4096);

    // 2. 计算虚拟页坐标
    int3 pageCoords = int3(
        floor(virtualUV * 32), // PAGE_TABLE_RESOLUTION
        i.cascadeIndex
    );

    // 3. 转换为环形缓冲坐标
    int2 cascadeOffset = _CascadeOffsets[i.cascadeIndex];
    int3 wrappedCoords = VirtualPageToWrapped(pageCoords, cascadeOffset);

    if (wrappedCoords.x < 0) discard;

    // 4. 查找页表
    uint pageEntry = _VirtualPageTable[wrappedCoords];

    // 5. 只写入已分配且脏的页面
    if (!GetIsAllocated(pageEntry) || !GetIsDirty(pageEntry))
        discard;

    // 6. 计算物理内存坐标
    int2 physicalPage = UnpackPhysicalCoords(pageEntry);
    int2 inPageOffset = virtualTexel % 128; // PAGE_SIZE
    int2 physicalTexel = physicalPage * 128 + inPageOffset;

    // 7. 原子写入深度（论文关键！）
    float fragmentDepth = i.pos.z; // gl_FragCoord.z
    InterlockedMin(_PhysicalMemory[physicalTexel], asuint(fragmentDepth));

    // 8. 输出深度到深度缓冲
    depth = fragmentDepth;
}
```

**关键点**：
1. 使用 `i.pos.z`（硬件插值深度）而非vertex shader传递的深度
2. 使用 `InterlockedMin` 保证多重采样正确性
3. 只渲染脏页面，跳过缓存页面

#### HPB剔除算法（可选高级优化）

**位置**：`Assets/Shaders/Include/VSMCommon.hlsl:139-170`

```hlsl
bool HPBCullTest(Bounds bounds, int cascade, Texture2DArray HPB)
{
    // 1. 投影包围盒到光空间
    float2 uvMin, uvMax;
    ProjectBoundsToLightSpace(bounds, cascadeMatrix, uvMin, uvMax);

    // 2. 选择合适的mip level（论文：正好覆盖4个texel）
    float2 texelSize = (uvMax - uvMin) * PAGE_TABLE_RES;
    int mipLevel = floor(log2(max(texelSize.x, texelSize.y) / 2.0));
    mipLevel = clamp(mipLevel, 0, HPB_MAX_LEVEL);

    // 3. 计算该mip下的texel范围
    int resolution = PAGE_TABLE_RES >> mipLevel;
    int2 texelMin = floor(uvMin * resolution);
    int2 texelMax = ceil(uvMax * resolution);

    // 4. 检查所有相交texel的dirty标志
    for (int y = texelMin.y; y <= texelMax.y; y++) {
        for (int x = texelMin.x; x <= texelMax.x; x++) {
            if (HPB[int3(x, y, cascade)] > 0.5) {
                return true; // 至少一个texel是dirty，通过剔除
            }
        }
    }

    return false; // 所有texel都不是dirty，剔除该几何体
}
```

**论文原文**：
> "When culling geometry against the HPB, we follow a process almost identical to culling against a Hi-Z. [...] we select the level in which the bounding-box bounds intersect exactly four texels. Lastly, if any of the four intersected texels is marked as dirty, the meshlet survives culling; otherwise, it is discarded."

---

### 阶段三：Sampling（采样阶段）

**位置**：`Assets/Shaders/VSM/VSMSampling.hlsl`

在主场景渲染时，材质调用VSM采样函数获取阴影。

#### 基础采样函数

```hlsl
float SampleVSM(float3 worldPos, float bias = 0.001)
{
    // 1. 选择级联
    int cascade = CalculateCascadeLevel(worldPos, cameraPos, cascade0Size);

    // 2. 转换到光空间
    float4x4 lightMatrix = _VSM_CascadeLightMatrices[cascade];
    float4 lightSpacePos = mul(lightMatrix, float4(worldPos, 1.0));
    float2 lightUV = lightSpacePos.xy * 0.5 + 0.5;

    // 3. 计算虚拟页坐标
    int3 pageCoords = int3(floor(lightUV * 32), cascade);

    // 4. 环形缓冲转换
    int2 offset = _VSM_CascadeOffsets[cascade];
    int3 wrappedCoords = VirtualPageToWrapped(pageCoords, offset);

    if (wrappedCoords.x < 0) return 1.0; // 不在范围内，无阴影

    // 5. 查找页表
    uint pageEntry = _VSM_VirtualPageTable[wrappedCoords];
    if (!GetIsAllocated(pageEntry)) return 1.0; // 页面未分配

    // 6. 获取物理页坐标
    int2 physicalPage = UnpackPhysicalCoords(pageEntry);

    // 7. 计算页内UV
    float2 pageUV = frac(lightUV * 32);

    // 8. 计算物理纹理UV
    float2 physicalUV = (physicalPage + pageUV) * 128 / float2(8192, 4096);

    // 9. 采样物理内存
    float shadowDepth = _VSM_PhysicalMemory.SampleLevel(sampler, physicalUV, 0);

    // 10. 深度比较
    float currentDepth = lightSpacePos.z;
    return (currentDepth - bias) > shadowDepth ? 0.0 : 1.0;
}
```

#### PCF滤波采样

```hlsl
float SampleVSM_PCF(float3 worldPos, float filterSize = 2.0)
{
    // ... 前面步骤相同 ...

    float shadow = 0.0;
    float weight = 0.0;

    // 3×3 PCF核
    for (int dy = -1; dy <= 1; dy++) {
        for (int dx = -1; dx <= 1; dx++) {
            float2 offset = float2(dx, dy) * texelSize * filterSize;
            float2 sampleUV = lightUV + offset;

            // 对每个采样重复虚拟→物理映射流程
            int3 samplePage = CalculatePageCoords(sampleUV, cascade);
            // ... 完整的页表查找 ...

            float depth = _VSM_PhysicalMemory.Sample(sampler, physicalUV);
            shadow += CompareDepth(currentDepth, depth, bias);
            weight += 1.0;
        }
    }

    return weight > 0 ? shadow / weight : 1.0;
}
```

**为何PCF需要filterMargin？**

论文12.2.3节指出：
> "When filtering, this assumption is broken. One or more samples from the filtering region may fall into parts of the world that are not visible from the main camera. [...] To mitigate the issue [...] the Mark Visible Pages pass must be modified. Instead of marking only the page directly corresponding to the visible texel, we mark all pages lying in a region around it."

解决方案：在Step 2中不仅标记像素对应的页面，还标记周围的页面（filterMargin参数）。

---

## 关键算法详解

### 1. 两种级联选择启发式对比

#### 启发式1：像素完美（Pixel-Perfect）

**公式**：`level = max(⌈log₂(T_w / T_c₀)⌉, 0)`

**原理**：追求屏幕像素与阴影纹素的1:1映射

**优点**：
- 理论最优细节分配
- 不浪费阴影分辨率

**缺点**：
- 相机旋转时级联切换频繁（抖动）
- 可能选中视锥外的级联
- 需要偏置（bias）调整

**使用场景**：静态或慢速旋转的相机

**实现**：
```hlsl
// 计算屏幕像素的世界尺寸
float GetScreenTexelWorldSize(float3 worldPos) {
    float4 clipPos = mul(viewProj, float4(worldPos, 1));
    float4 clipPosOffset = clipPos + float4(2.0/screenWidth, 0, 0, 0);

    float3 worldPos2 = UnprojectToWorld(clipPosOffset);
    return length(worldPos2 - worldPos);
}

// 启发式1
int level = ceil(log2(GetScreenTexelWorldSize(pos) / cascade0TexelSize));
```

#### 启发式2：基于距离（Distance-Based）

**公式**：`level = max(⌈log₂(d / s_c₀)⌉, 0)`

**原理**：根据距相机距离选择级联

**优点**：
- **旋转不变性** - 相机旋转时级联保持稳定
- 实现简单
- 不会选到视锥外

**缺点**：
- 非严格1:1映射
- 可能在某些角度过采样或欠采样

**使用场景**：自由视角游戏、FPS

**实现**：
```hlsl
float distance = length(worldPos - cameraPos);
int level = ceil(log2(distance / firstCascadeSize));
```

**论文总结**：
> "Although this heuristic has a theoretically optimal cascade selection, it does not take into account the available resolution of each cascade. [...] An advantage of this heuristic is that the chosen level for a given location in world space is rotationally invariant."

### 2. 光源位置平面约束

**目的**：保证缓存页面的深度值在光源移动时仍然有效

**论文要求**：
> "the light position is constrained so that, when modified, it slides along a plane parallel to the near-plane of the respective light matrix. This constraint is necessary for the depth stored in cached pages to remain valid even after translating the light matrix."

**实现原理**：

```
        光源移动方向
              ↓
    ──────────────────  ← 平行于near-plane的约束平面
         ║   ║   ║
         ║   ║   ║      光线方向（垂直于平面）
         ▼   ▼   ▼

    场景物体（深度值保持不变）
```

**代码实现**：
```csharp
// 1. 计算光源视图的right和up向量（平面基向量）
Vector3 lightDir = directionalLight.forward;
Vector3 right = Vector3.Cross(lightDir, Vector3.up).normalized;
Vector3 up = Vector3.Cross(right, lightDir).normalized;

// 2. 初始光源位置
Vector3 lightPos = snappedCameraPos - lightDir * cascadeSize;

// 3. 投影到约束平面并对齐网格
float rightOffset = Vector3.Dot(lightPos, right);
float upOffset = Vector3.Dot(lightPos, up);
rightOffset = Mathf.Floor(rightOffset / pageWorldSize) * pageWorldSize;
upOffset = Mathf.Floor(upOffset / pageWorldSize) * pageWorldSize;

// 4. 重建约束后的光源位置
float depthOffset = Vector3.Dot(lightPos, lightDir);
lightPos = right * rightOffset + up * upOffset + lightDir * depthOffset;
```

**效果**：光源只能在垂直于光线方向的平面上移动，深度方向保持固定，缓存页面深度值始终有效。

### 3. 滑动窗口（2D Wraparound Addressing）

**问题**：相机移动时，新页面进入视野，旧页面退出

**传统方案**：清空并重新分配所有页面 ❌

**VSM方案**：环形缓冲，新页面复用旧页面的VPT位置 ✅

**示意图**：
```
相机向右移动：

旧视野：          新视野：
┌─┬─┬─┬─┐        ┌─┬─┬─┬─┐
│A│B│C│D│        │ │B│C│D│E│
├─┼─┼─┼─┤   →    ├─┼─┼─┼─┤
│E│F│G│H│        │ │F│G│H│I│
└─┴─┴─┴─┘        └─┴─┴─┴─┘
退出←        →进入

VPT复用：
A的位置 → 存储E的数据
E的位置 → 存储I的数据
```

**实现**：
```hlsl
int2 VirtualPageToWrapped(int2 pageCoords, int2 cascadeOffset) {
    int2 offsetCoords = pageCoords + cascadeOffset;
    int2 wrapped = offsetCoords % PAGE_TABLE_RESOLUTION;

    // 处理负数模运算
    if (wrapped.x < 0) wrapped.x += PAGE_TABLE_RESOLUTION;
    if (wrapped.y < 0) wrapped.y += PAGE_TABLE_RESOLUTION;

    return wrapped;
}
```

**优点**：
- 保留大部分缓存页面
- 只重新渲染边缘的新页面
- 避免全局刷新

### 4. 层级页面缓冲（HPB）剔除原理

**目标**：避免渲染不会影响任何脏页面的几何体

**类比**：Hi-Z用深度值剔除被遮挡物体，HPB用脏标志剔除不影响脏页的物体

**Mip链构建**：
```hlsl
// 伪代码
HPB[0] = ExtractDirtyFlags(VPT);  // 32×32

for (level = 1; level < maxLevel; level++) {
    for (每个texel in HPB[level]) {
        // 2×2 max reduction
        float4 children = SampleChildren(HPB[level-1]);
        HPB[level][texel] = max(max(children.x, children.y),
                                 max(children.z, children.w));
    }
}
```

**剔除测试**：
```
1. 项目包围盒 → 光空间UV范围 [uvMin, uvMax]

2. 选择mip level:
   - 计算UV范围覆盖的texel数量
   - 选择让包围盒正好覆盖≈4个texel的level

3. 读取这4个（或更多）texel的dirty值

4. 判断：
   - 任一texel == 1.0 → 通过剔除（需要渲染）
   - 全部texel == 0.0 → 被剔除（跳过渲染）
```

**效率分析**：
- 传统：渲染所有16个级联的所有几何 ≈ 16N次drawcall
- HPB剔除：只渲染影响脏页的几何 ≈ 0.1N ~ 2N次drawcall（取决于缓存率）

---

## 数据结构设计

### 虚拟页表（VPT）条目格式

**32位打包结构**：

```
Bit 31      25 24      14 13     3  2  1  0
┌───────────┬───────────┬────────┬──┬──┬──┐
│ PhysY     │  PhysX    │ (保留) │D │V │A │
│ (11 bits) │ (11 bits) │        │  │  │  │
└───────────┴───────────┴────────┴──┴──┴──┘
                                    │  │  └─ Allocated (已分配)
                                    │  └──── Visible (可见)
                                    └─────── Dirty (脏)
```

**编解码函数**：
```hlsl
// 编码
uint PackPageEntry(bool allocated, bool visible, bool dirty, int2 physicalCoords)
{
    uint result = 0;
    if (allocated) result |= 0x1u;
    if (visible)   result |= 0x2u;
    if (dirty)     result |= 0x4u;
    result |= (physicalCoords.x & 0x7FFu) << 3;
    result |= (physicalCoords.y & 0x7FFu) << 14;
    return result;
}

// 解码
int2 UnpackPhysicalPageCoords(uint entry)
{
    int x = (entry >> 3) & 0x7FFu;
    int y = (entry >> 14) & 0x7FFu;
    return int2(x, y);
}

bool GetIsAllocated(uint entry) { return (entry & 0x1u) != 0; }
bool GetIsVisible(uint entry)   { return (entry & 0x2u) != 0; }
bool GetIsDirty(uint entry)     { return (entry & 0x4u) != 0; }
```

### 物理内存布局

**纹理格式**：8192×4096，R32_Float

**页面排列**：

```
物理内存 (8192×4096)
┌──────────────────────────────────────────┐
│ 页0   页1   页2   ...   页62  页63        │ ← 行0 (64页)
│128×128 ...                                │
├──────────────────────────────────────────┤
│ 页64  页65  页66  ...   页126 页127       │ ← 行1
│                                           │
├──────────────────────────────────────────┤
│  ...                                      │
├──────────────────────────────────────────┤
│ 页1984 ...               页2047          │ ← 行31 (最后一行)
└──────────────────────────────────────────┘

总页数 = 64列 × 32行 = 2048页
每页 = 128×128 = 16,384像素
```

**坐标转换**：
```hlsl
// 物理页索引 → 2D坐标
int2 PhysicalPageIndexToCoords(uint index) {
    return int2(index % 64, index / 64);
}

// 2D坐标 → 物理页索引
uint PhysicalPageCoordsToIndex(int2 coords) {
    return coords.y * 64 + coords.x;
}

// 虚拟纹素 → 物理纹素
int2 VirtualTexelToPhysical(int2 virtualTexel, int2 physicalPage) {
    int2 inPageOffset = virtualTexel % 128;
    return physicalPage * 128 + inPageOffset;
}
```

### 缓冲区详细设计

#### 分配请求缓冲（AllocationRequests）
```cpp
struct AllocationRequest {
    int3 pageCoords;  // (x, y, cascadeIndex)
    uint padding;     // 对齐到16字节
};

ComputeBuffer allocationRequests = new ComputeBuffer(
    32 * 32 * 16,           // 最大请求数 = 所有虚拟页
    sizeof(uint) * 4,        // 16字节/请求
    ComputeBufferType.Append
);
```

#### 物理页缓冲（FreePages & UsedPages）
```cpp
struct PhysicalPageCoords {
    int2 coords;  // (列, 行)
};

ComputeBuffer freePages = new ComputeBuffer(
    2048,                    // 最大物理页数
    sizeof(uint) * 2,        // 8字节/页
    ComputeBufferType.Append
);

ComputeBuffer usedPages = new ComputeBuffer(
    2048,
    sizeof(uint) * 2,
    ComputeBufferType.Append
);
```

#### 物理页表（PPT）
```cpp
struct PhysicalPageTableEntry {
    int3 virtualPageCoords;  // 反向映射
    uint flags;              // 状态标志
};

ComputeBuffer physicalPageTable = new ComputeBuffer(
    2048,
    sizeof(uint) * 4,  // 16字节/条目
    ComputeBufferType.Default
);
```

---

## Shader实现细节

### Compute Shader执行配置

#### 线程组大小选择

```hlsl
// 页表相关（32×32）
[numthreads(8, 8, 1)]  // 覆盖32×32需要 4×4 = 16个线程组

// 物理页相关（64×32 = 2048）
[numthreads(64, 1, 1)]  // 线性处理，32个线程组

// 屏幕分析（1920×1080）
[numthreads(8, 8, 1)]  // 需要 240×135 = 32,400个线程组
```

#### 间接调度（Indirect Dispatch）

**用途**：根据运行时数据动态确定线程组数量

```cpp
// CPU端准备间接参数
ComputeBuffer indirectArgs = new ComputeBuffer(3, sizeof(uint));
ComputeBuffer.CopyCount(allocationRequests, indirectArgs, 0);

uint[] args = new uint[3];
indirectArgs.GetData(args);
args[0] = (args[0] + 63) / 64;  // X = ceil(count / 64)
args[1] = 1;
args[2] = 1;
indirectArgs.SetData(args);

// GPU端执行
computeShader.DispatchIndirect(kernel, indirectArgs);
```

### 原子操作使用

#### InterlockedMin用于深度写入

**为什么不直接写入？**

```hlsl
// ❌ 错误：多个fragment可能写入同一像素
_PhysicalMemory[texel] = depth;

// ✅ 正确：原子min保证取最小深度
InterlockedMin(_PhysicalMemory[texel], asuint(depth));
```

**场景**：
1. 三角形边缘重叠
2. Alpha测试几何（草、叶子）
3. 多层几何（头发、粒子）

**深度格式转换**：
```hlsl
// float → uint (保持排序)
uint depthUint = asuint(depthFloat);

// uint → float (读取时)
float depthFloat = asfloat(depthUint);
```

IEEE 754保证：正浮点数的整数表示保持相同顺序。

#### InterlockedOr用于标志设置

```hlsl
// 原子设置visible位
InterlockedOr(_VirtualPageTable[coords], VSM_VISIBLE_BIT);

// 多线程安全，不会覆盖其他位
```

#### InterlockedAdd用于分配计数

```hlsl
uint freeIndex;
InterlockedAdd(_AllocationCounter[0], 1, freeIndex);

if (freeIndex < freePageCount) {
    // 安全获取唯一的物理页
    PhysicalPage page = _FreePages[freeIndex];
}
```

### 纹理采样优化

#### Mipmap考虑

VSM物理内存**不使用mipmap**：
- 每个级联已经是不同细节层级
- 物理页不连续，无法生成有效mipmap
- 使用`SampleLevel(..., 0)`强制LOD 0

#### 滤波模式

```cpp
// VPT：必须Point采样
virtualPageTable.filterMode = FilterMode.Point;

// 物理内存：可选Bilinear（PCF需要）
physicalMemory.filterMode = FilterMode.Bilinear;

// HPB：Point采样（离散dirty标志）
hpb.filterMode = FilterMode.Point;
```

---

## 使用指南

### 快速开始

#### 1. 场景设置

```
1. 创建空GameObject，命名"VSMManager"
2. 添加Camera组件（主相机）
3. 添加VirtualShadowMapManager脚本
4. 创建Directional Light
```

#### 2. Inspector配置

**VSM Settings:**
- `Directional Light`: 拖入场景中的平行光
- `First Cascade Size`: 2.0（第一级联边长，米）
- `Shadow Casters`: 选择投射阴影的层级
- `Filter Margin`: 1（PCF滤波边缘页数）

**Cascade Selection Heuristic:**
- `Use Pixel Perfect Heuristic`: false（距离启发式）
- `Cascade Bias`: 0（级联偏移）

**Compute Shaders:**（拖入对应shader）
- `Free Invalidated Pages Shader`: VSMFreeInvalidatedPages
- `Mark Visible Pages Shader`: VSMMarkVisiblePages
- `Allocate Pages Shader`: VSMAllocatePages
- `Clear Pages Shader`: VSMClearPages
- `Build HPB Shader`: VSMBuildHPB

**Rendering:**
- `VSM Depth Shader`: VSMDepthRender
- `VSM Depth Material`: 自动创建或手动指定

**Debug:**
- `Debug Visualization`: 勾选以显示调试信息

#### 3. 材质设置

在场景物体的shader中添加VSM采样：

```hlsl
#include "Assets/Shaders/VSM/VSMSampling.hlsl"

// 在fragment shader中
float3 worldPos = i.worldPos;
float shadow = SampleVSM_PCF(worldPos, 2.0, 0.001);

finalColor.rgb *= shadow; // 应用阴影
```

#### 4. 运行测试

1. 进入Play模式
2. 移动主相机，观察阴影更新
3. 开启Debug可视化查看状态

### 参数调优指南

#### First Cascade Size（第一级联尺寸）

**影响**：所有级联的基础分辨率

```
级联0: firstCascadeSize = 2m
  → 虚拟分辨率 4096×4096
  → 纹素世界尺寸 = 2m / 4096 ≈ 0.5mm/texel

级联1: 4m → 1mm/texel
级联2: 8m → 2mm/texel
...
```

**选择建议**：
- **室内/小场景**: 1.0 - 2.0米（高精度）
- **室外/中场景**: 2.0 - 4.0米（平衡）
- **大型开放世界**: 4.0 - 8.0米（性能优先）

#### Filter Margin（滤波边缘）

**作用**：为PCF滤波预留的页面边缘

```
filterMargin = 0: 无PCF滤波（硬阴影）
filterMargin = 1: 3×3 PCF（推荐）
filterMargin = 2: 5×5 PCF（更软，更多页面）
filterMargin = 3: 7×7 PCF（最软，性能开销大）
```

**内存影响**：
- margin=0: 标记1个页面/像素
- margin=1: 标记9个页面/像素（3×3）
- margin=2: 标记25个页面/像素（5×5）

**建议**：从1开始，根据阴影质量需求调整

#### Cascade Bias（级联偏移）

**用途**：微调级联选择，避免边缘切换

```hlsl
level = ⌈log₂(distance / size)⌉ + bias
```

- **bias = 0**: 标准选择
- **bias = -1**: 偏向更高级联（更细节，更多内存）
- **bias = +1**: 偏向更低级联（更粗糙，节省内存）

**使用场景**：
- 频繁级联切换 → bias = +0.5（平滑过渡）
- 远处细节不足 → bias = -0.5（提升远处质量）

#### 启发式选择

| 场景类型 | 推荐启发式 | 原因 |
|---------|-----------|------|
| FPS游戏 | 距离启发式 | 旋转频繁，需要稳定性 |
| 策略游戏 | 像素完美 | 固定视角，追求最优细节 |
| 第三人称 | 距离启发式 | 相机运动复杂 |
| 建筑漫游 | 像素完美 + bias调整 | 静态场景，高质量要求 |

### 性能分析工具

#### 调试可视化

**启用方法**：Inspector勾选"Debug Visualization"

**显示信息**：
```
Virtual Shadow Maps Active
Physical Memory: 8192x4096
Cascades: 16
```

#### Frame Debugger使用

```
1. Window → Analysis → Frame Debugger
2. Enable → Capture
3. 查找 "Virtual Shadow Maps" CommandBuffer
4. 展开查看每个cascade的drawcall
```

**关注指标**：
- DrawMesh数量（剔除效率）
- SetTexture/SetBuffer调用（状态切换）
- Compute Dispatch次数

#### 性能计数器

在VirtualShadowMapManager添加：

```csharp
public struct VSMStats {
    public int allocatedPages;
    public int visiblePages;
    public int dirtyPages;
    public int drawCalls;
}

public VSMStats GetStats() {
    VSMStats stats;
    // ... 从GPU读取统计数据
    return stats;
}
```

---

## 性能优化

### 内存优化

#### 1. 级联数量调整

```csharp
// 默认：16级联
public const int CASCADE_COUNT = 16;  // 覆盖65km

// 室内场景：8级联足够
public const int CASCADE_COUNT = 8;   // 覆盖256m

// 极限性能：4级联
public const int CASCADE_COUNT = 4;   // 覆盖16m
```

**影响**：
- VPT大小：32×32×N
- 级联矩阵：N×16 floats
- HPB大小：与N成正比

#### 2. 页面分辨率调整

```csharp
// 默认：128×128/页
public const int PAGE_SIZE = 128;

// 降低精度换性能：64×64/页
public const int PAGE_SIZE = 64;  // 4倍物理页数

// 提升质量：256×256/页
public const int PAGE_SIZE = 256; // 1/4物理页数
```

**权衡**：
- 页面越大 → 缓存命中率↓，浪费↑
- 页面越小 → 页表开销↑，管理复杂度↑

#### 3. 物理内存池大小

```csharp
// 默认：8192×4096 = 2048页
public const int PHYSICAL_MEMORY_WIDTH = 8192;
public const int PHYSICAL_MEMORY_HEIGHT = 4096;

// 内存受限：4096×4096 = 1024页
public const int PHYSICAL_MEMORY_WIDTH = 4096;
public const int PHYSICAL_MEMORY_HEIGHT = 4096;

// 高端配置：16384×4096 = 4096页
public const int PHYSICAL_MEMORY_WIDTH = 16384;
```

**建议配置**：

| 目标平台 | 物理内存 | 页数 | 显存占用 |
|---------|---------|------|---------|
| 移动端 | 2048×2048 | 256 | ~16MB |
| 主机/中端PC | 8192×4096 | 2048 | ~128MB |
| 高端PC | 16384×8192 | 8192 | ~512MB |

### 渲染优化

#### 1. HPB剔除集成

**完整实现步骤**：

```csharp
// a. 准备meshlet数据
struct Meshlet {
    float3 boundsMin;
    float3 boundsMax;
    uint meshletIndex;
}

ComputeBuffer meshletBuffer;

// b. 执行HPB剔除
ComputeBuffer visibleMeshlets = new ComputeBuffer(maxMeshlets, 4, Append);
cullShader.SetBuffer(kernel, "_Meshlets", meshletBuffer);
cullShader.SetBuffer(kernel, "_VisibleMeshlets", visibleMeshlets);
cullShader.SetTexture(kernel, "_HPB", hpb.GetMipLevel(0));
cullShader.Dispatch(kernel, meshletCount/64, 1, 1);

// c. 间接绘制
ComputeBuffer indirectArgs;
ComputeBuffer.CopyCount(visibleMeshlets, indirectArgs, 0);
Graphics.DrawMeshInstancedIndirect(mesh, 0, material, bounds, indirectArgs);
```

**性能提升**：
- 静态场景：减少90%+ drawcall
- 动态场景：减少50-70% drawcall

#### 2. 批量渲染

**GPU Instancing**：

```csharp
// 收集相同mesh的所有实例
List<Matrix4x4> matrices;
foreach (Renderer r in renderers) {
    if (r.sharedMesh == targetMesh) {
        matrices.Add(r.localToWorldMatrix);
    }
}

// 单次drawcall渲染所有实例
vsmCommandBuffer.DrawMeshInstanced(
    targetMesh,
    0,
    vsmDepthMaterial,
    0,
    matrices.ToArray()
);
```

#### 3. LOD整合

```csharp
// 根据级联选择LOD
int GetLODForCascade(int cascade) {
    if (cascade < 4) return 0;  // 高精度级联用LOD0
    if (cascade < 8) return 1;
    if (cascade < 12) return 2;
    return 3;  // 远距离用最低LOD
}

// 渲染时应用
foreach (Renderer r in renderers) {
    int lod = GetLODForCascade(currentCascade);
    Mesh mesh = r.GetComponent<LODGroup>().GetLODs()[lod].renderers[0].sharedMesh;
    vsmCommandBuffer.DrawMesh(mesh, ...);
}
```

### CPU优化

#### 1. 对象池

```csharp
// 避免每帧FindObjectsOfType
private Renderer[] cachedRenderers;
private bool renderersDirty = true;

void UpdateRendererCache() {
    if (renderersDirty) {
        cachedRenderers = FindObjectsOfType<Renderer>();
        renderersDirty = false;
    }
}

// 物体添加/删除时标记dirty
public void OnRendererAdded() { renderersDirty = true; }
```

#### 2. 空间分区

```csharp
// 八叉树加速级联剔除
Octree<Renderer> spatialIndex;

void DrawingPhase() {
    for (int cascade = 0; cascade < 16; cascade++) {
        Bounds cascadeBounds = GetCascadeBounds(cascade);
        List<Renderer> candidates = spatialIndex.Query(cascadeBounds);

        foreach (Renderer r in candidates) {
            // 只检查附近的物体
        }
    }
}
```

#### 3. 多线程任务

```csharp
// 在Job System中执行视锥剔除
struct FrustumCullJob : IJobParallelFor {
    [ReadOnly] public NativeArray<Bounds> bounds;
    [ReadOnly] public Matrix4x4 lightMatrix;
    [WriteOnly] public NativeArray<bool> results;

    public void Execute(int index) {
        results[index] = IsInFrustum(bounds[index], lightMatrix);
    }
}

// 调度
var job = new FrustumCullJob { ... };
var handle = job.Schedule(rendererCount, 64);
handle.Complete();
```

### GPU优化

#### 1. Async Compute

```csharp
// 在异步队列执行Bookkeeping
CommandBuffer bookkeepingCmd = new CommandBuffer();
bookkeepingCmd.name = "VSM Bookkeeping";

// 添加所有compute dispatches...

// 异步执行
Graphics.ExecuteCommandBufferAsync(
    bookkeepingCmd,
    ComputeQueueType.Background
);
```

#### 2. UAV障碍优化

```hlsl
// ❌ 每次写入后barrier
for (int i = 0; i < count; i++) {
    VPT[i] = ...;
    AllMemoryBarrierWithGroupSync();  // 昂贵！
}

// ✅ 批量写入后单次barrier
for (int i = 0; i < count; i++) {
    VPT[i] = ...;
}
AllMemoryBarrierWithGroupSync();  // 仅一次
```

#### 3. 波前占用率

```hlsl
// 调整线程组大小匹配GPU波前
// NVIDIA (32-wide): [numthreads(32,1,1)] 或 [numthreads(8,4,1)]
// AMD (64-wide):    [numthreads(64,1,1)] 或 [numthreads(8,8,1)]

// 避免
[numthreads(33,1,1)]  // 浪费31个线程
```

---

## 问题排查

### 常见问题

#### 问题1：阴影完全不显示

**可能原因**：
1. ✅ DrawingPhase未执行
2. ✅ 物理内存未正确绑定
3. ✅ 材质未包含VSM采样代码
4. ✅ 光源方向错误

**排查步骤**：
```csharp
// 1. 添加日志
void DrawingPhase() {
    Debug.Log($"Drawing {cascadeCount} cascades");
    if (vsmDepthMaterial == null) {
        Debug.LogError("VSM Depth Material is null!");
        return;
    }
    // ...
}

// 2. 检查物理内存
void OnGUI() {
    if (GUILayout.Button("Check Physical Memory")) {
        RenderTexture.active = physicalMemory.Texture;
        Texture2D readback = new Texture2D(256, 256);
        readback.ReadPixels(new Rect(0,0,256,256), 0, 0);
        readback.Apply();

        // 保存查看
        File.WriteAllBytes("vsm_debug.png", readback.EncodeToPNG());
    }
}

// 3. 验证采样
// 在材质shader中临时返回固定颜色
float shadow = SampleVSM(worldPos);
return float4(shadow, 0, 0, 1); // 应显示红色渐变
```

#### 问题2：阴影闪烁/抖动

**原因分析**：
- **相机移动**：页面缓存失效频繁
- **光源抖动**：未正确实现平面约束
- **级联切换**：启发式导致级联跳变

**解决方案**：

```csharp
// a. 增加缓存稳定性
float pageWorldSize = cascadeSize / PAGE_TABLE_RESOLUTION;
// 加大对齐粒度
pageWorldSize *= 2.0f;

// b. 验证光源约束
Debug.DrawRay(lightPos, lightDir, Color.yellow);
Debug.DrawRay(lightPos, right, Color.red);
Debug.DrawRay(lightPos, up, Color.green);
// 移动光源时，黄线应保持固定方向

// c. 切换启发式
usePixelPerfectHeuristic = false; // 距离启发式更稳定

// d. 添加级联bias
cascadeBias = 0.5f; // 减少边界切换
```

#### 问题3：阴影有锯齿

**原因**：
- filterMargin设置为0（无PCF）
- 级联选择不当
- 物理内存不足

**优化方案**：

```csharp
// 1. 启用PCF
filterMargin = 1;  // 3×3 PCF

// 2. 在shader中增大滤波核
float shadow = SampleVSM_PCF(worldPos, 3.0); // filterSize=3

// 3. 提升首级联分辨率
firstCascadeSize = 1.0f; // 从2.0降到1.0

// 4. 检查级联选择
void OnDrawGizmos() {
    // 可视化级联
    for (int i = 0; i < 16; i++) {
        Gizmos.color = Color.HSVToRGB(i/16f, 1, 1);
        DrawCascadeBounds(i);
    }
}
```

#### 问题4：性能过低

**诊断**：

```csharp
// 添加性能计时
Profiler.BeginSample("VSM Bookkeeping");
BookkeepingPhase();
Profiler.EndSample();

Profiler.BeginSample("VSM Drawing");
DrawingPhase();
Profiler.EndSample();
```

**常见瓶颈**：

| 瓶颈 | 表现 | 解决方案 |
|-----|------|---------|
| GPU Compute | Bookkeeping耗时>5ms | 减少级联数量 |
| DrawCall | Drawing耗时>10ms | 启用HPB剔除、GPU Instancing |
| 内存带宽 | 整体卡顿 | 降低物理内存分辨率 |
| CPU剔除 | CPU占用高 | 空间分区、Job System |

#### 问题5：远处阴影消失

**原因**：级联覆盖范围不足

**计算覆盖范围**：
```
级联N的最远距离 = firstCascadeSize × 2^N

例如：
firstCascadeSize = 2m
级联15: 2 × 2^15 = 65,536m = 65.5km
```

**解决**：
```csharp
// 方案1: 增加级联数（慎用，性能开销大）
CASCADE_COUNT = 20; // 覆盖1,048km

// 方案2: 增大首级联尺寸
firstCascadeSize = 4.0f; // 覆盖131km

// 方案3: 混合方案
// 近处精细级联 + 远处单个低精度shadow map
```

### 调试工具

#### 1. 可视化级联分布

```csharp
void OnDrawGizmos() {
    if (!Application.isPlaying) return;

    for (int i = 0; i < CASCADE_COUNT; i++) {
        Gizmos.color = new Color(i/16f, 1-i/16f, 0.5f, 0.3f);

        Matrix4x4 mat = cascadeLightMatrices[i];
        Vector3 center = mat.inverse.MultiplyPoint(Vector3.zero);
        float size = firstCascadeSize * Mathf.Pow(2, i);

        Gizmos.DrawWireCube(center, Vector3.one * size);

        // 显示级联编号
        #if UNITY_EDITOR
        UnityEditor.Handles.Label(center, $"Cascade {i}");
        #endif
    }
}
```

#### 2. 页表查看器

```csharp
public Texture2D GeneratePageTableVisualization(int cascade) {
    RenderTexture.active = pageTable.VirtualPageTableTexture;

    Texture2D tex = new Texture2D(32, 32);
    Color[] pixels = new Color[32 * 32];

    for (int y = 0; y < 32; y++) {
        for (int x = 0; x < 32; x++) {
            uint entry = ReadPageEntry(x, y, cascade);

            if (GetIsAllocated(entry) && GetIsVisible(entry) && GetIsDirty(entry))
                pixels[y*32+x] = Color.red;      // 红：待渲染
            else if (GetIsAllocated(entry) && GetIsVisible(entry))
                pixels[y*32+x] = Color.green;    // 绿：已渲染
            else if (GetIsAllocated(entry))
                pixels[y*32+x] = Color.blue;     // 蓝：缓存
            else
                pixels[y*32+x] = Color.black;    // 黑：未分配
        }
    }

    tex.SetPixels(pixels);
    tex.Apply();
    return tex;
}
```

#### 3. 实时统计面板

```csharp
void OnGUI() {
    if (!debugVisualization) return;

    GUILayout.BeginArea(new Rect(10, 10, 300, 400));
    GUILayout.Label("=== VSM Statistics ===");

    // 计算统计数据
    int totalPages = 32 * 32 * CASCADE_COUNT;
    int allocatedPages = CountAllocatedPages();
    int dirtyPages = CountDirtyPages();

    GUILayout.Label($"Total Virtual Pages: {totalPages}");
    GUILayout.Label($"Allocated Pages: {allocatedPages} ({100f*allocatedPages/totalPages:F1}%)");
    GUILayout.Label($"Dirty Pages: {dirtyPages}");
    GUILayout.Label($"Physical Pages: {MAX_PHYSICAL_PAGES}");
    GUILayout.Label($"Memory Usage: {CalculateMemoryMB():F1} MB");

    GUILayout.Space(10);
    GUILayout.Label("=== Performance ===");
    GUILayout.Label($"Bookkeeping: {bookkeepingTime:F2} ms");
    GUILayout.Label($"Drawing: {drawingTime:F2} ms");
    GUILayout.Label($"DrawCalls: {drawCallCount}");

    GUILayout.EndArea();
}
```

---

## 附录

### 完整代码位置索引

#### C# 脚本
- **VirtualShadowMapManager.cs** - 主管理器
  - `Start()` - 初始化 (58-61)
  - `UpdateCascadeMatrices()` - 级联矩阵 (87-150)
  - `BookkeepingPhase()` - 准备阶段 (178-318)
  - `DrawingPhase()` - 绘制阶段 (320-384) ⭐
  - `IsInCascadeFrustum()` - 视锥剔除 (386-421)

- **VSMPageTable.cs** - 页表管理 (10-157)
- **VSMPhysicalMemory.cs** - 物理内存管理
- **VSMHierarchicalPageBuffer.cs** - HPB管理 (52-80)
- **VSMConstants.cs** - 常量定义

#### Compute Shaders
- **VSMFreeInvalidatedPages.compute** - 释放页面
- **VSMMarkVisiblePages.compute** - 标记可见页 (40-104)
- **VSMAllocatePages.compute** - 分配页面 (1-172)
- **VSMClearPages.compute** - 清除页面
- **VSMBuildHPB.compute** - 构建HPB (1-44)
- **VSMCullAndDraw.compute** - HPB剔除示例 (1-49)

#### 渲染 Shaders
- **VSMDepthRender.shader** - 深度渲染 (67-115)
- **VSMSampling.hlsl** - 采样函数 (18-127)
- **VSMCommon.hlsl** - 公共函数库 (1-172)

### 参数速查表

| 参数 | 默认值 | 范围 | 说明 |
|-----|-------|------|------|
| PAGE_TABLE_RESOLUTION | 32 | 16-64 | 每级联页表分辨率 |
| PAGE_SIZE | 128 | 64-256 | 每页像素数 |
| CASCADE_COUNT | 16 | 4-20 | 级联数量 |
| PHYSICAL_MEMORY_WIDTH | 8192 | 2048-16384 | 物理内存宽度 |
| PHYSICAL_MEMORY_HEIGHT | 4096 | 2048-8192 | 物理内存高度 |
| firstCascadeSize | 2.0 | 0.5-8.0 | 首级联边长(米) |
| filterMargin | 1 | 0-3 | PCF滤波边缘 |
| cascadeBias | 0 | -2 ~ +2 | 级联选择偏移 |

### 公式汇总

**级联选择**：
```
距离启发式: level = ⌈log₂(d / s_c₀)⌉
像素完美:   level = ⌈log₂(T_w / T_c₀)⌉
```

**坐标转换**：
```
虚拟UV → 页坐标: pageCoords = floor(virtualUV × 32)
环形映射:        wrappedCoords = (pageCoords + offset) % 32
物理坐标:        physicalTexel = physicalPage × 128 + inPageOffset
```

**覆盖范围**：
```
级联N最远距离 = firstCascadeSize × 2^N
虚拟分辨率 = PAGE_TABLE_RESOLUTION × PAGE_SIZE = 32 × 128 = 4096
物理页数 = (WIDTH / PAGE_SIZE) × (HEIGHT / PAGE_SIZE) = 64 × 32 = 2048
```

### 论文对照

| 论文章节 | 实现位置 | 页码 |
|---------|---------|------|
| 12.1 Introduction | README.md | - |
| 12.2 Implementation | VirtualShadowMapManager.cs | - |
| 12.2.1 Bookkeeping | 行178-318 | - |
| - Listing 12.1 滑动窗口 | VSMCommon.hlsl:55-75 | - |
| - Listing 12.2 释放页面 | VSMFreeInvalidatedPages.compute | - |
| 12.2.2 Drawing Phase | 行320-384 | - |
| - Listing 12.3 Fragment Shader | VSMDepthRender.shader:67-115 | - |
| 12.2.3 Sampling Phase | VSMSampling.hlsl | - |

---

## 总结

虚拟阴影贴图是一项复杂但强大的技术，通过虚拟内存抽象实现了：

1. **极致的分辨率** - 4096×4096×16级联虚拟空间
2. **极低的开销** - 稀疏分配，只占用可见页面
3. **统一的管线** - 单一方案替代多种阴影技术
4. **智能的缓存** - 页面重用，减少重复渲染

### 三大核心机制
- **虚拟页表** - 灵活的虚拟→物理映射
- **滑动窗口** - 高效的缓存复用
- **HPB剔除** - 精准的几何裁剪

### 关键优势
✅ 支持Nanite级别的高多边形场景
✅ 自适应细节分配，无需手动调优
✅ 旋转不变的级联选择
✅ 原生支持软阴影（PCF/PCSS）

### 实现要点
1. 严格遵循论文的两阶段分配策略
2. 正确实现光源位置平面约束
3. 使用硬件插值深度值（gl_FragCoord.z）
4. HPB剔除是性能关键

**本文档覆盖了从原理到实现的完整知识体系，可作为VSM技术的权威参考。**

---

**文档版本**: 1.0
**最后更新**: 2025-10-03
**作者**: VSM Implementation Team
**基于论文**: GPU Zen 3, Chapter 12 - Virtual Shadow Maps
